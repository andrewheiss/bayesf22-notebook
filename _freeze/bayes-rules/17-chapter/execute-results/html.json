{
  "hash": "ce5e7f872b5e3dff5059b35a27d878a9",
  "result": {
    "markdown": "---\ntitle: \"17: Hierarchical models with predictors\"\nsubtitle: \"Reading notes\"\ndate: \"November 2, 2022\"\n---\n\n\n[(Original chapter)](https://www.bayesrulesbook.com/chapter-17.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(rstanarm)\nlibrary(broom)\nlibrary(broom.mixed)\nlibrary(tidybayes)\nlibrary(patchwork)\nlibrary(scales)\nlibrary(ggtext)\nlibrary(ggh4x)  # For coord_axes_inside()\n\noptions(width = 100)\n\n# Plot stuff\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Tell bayesplot to use the Lakota palette for things like pp_check()\n# bayesplot::color_scheme_set(clrs)\n\n# Tell bayesplot to use the viridis rocket palette for things like pp_check()\nviridisLite::viridis(6, option = \"rocket\", end = 0.85, direction = -1) |> \n  # Take off the trailing \"FF\" in the hex codes\n  map_chr(~str_sub(., 1, 7)) |> \n  bayesplot::color_scheme_set()\n\n# Seed stuff\nset.seed(1234)\nBAYES_SEED <- 1234\n\n# Data\ndata(cherry_blossom_sample, package = \"bayesrules\")\n\nrunning <- cherry_blossom_sample |> \n  select(runner, age, net) |> \n  na.omit() |> \n  mutate(runner_nice = glue::glue(\"Runner {runner}\"),\n         runner_nice = fct_inorder(runner_nice)) |> \n  mutate(across(c(net, age), \n                ~scale(., scale = FALSE), .names = \"{col}_c\"))\n\nextract_attributes <- function(x) {\n  attributes(x) %>%\n    set_names(janitor::make_clean_names(names(.))) %>%\n    as_tibble() %>%\n    slice(1)\n}\n\nunscaled <- running %>%\n  select(ends_with(\"_c\")) |> \n  summarize(across(everything(), ~extract_attributes(.))) |> \n  pivot_longer(everything()) |> \n  unnest(value) |> \n  split(~name)\n\n# Access these things like so:\n# unscaled$age_c$scaled_center\n```\n:::\n\n\n# The general setup\n\nIn this chapter we're back to the running data from [chapter 15](/bayes-rules/15-chapter.qmd), with race times nested in runners:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Partial pooling with hierarchical models](15-chapter_files/figure-html/partial-pooling-1.svg){fig-align='center' width=100%}\n:::\n:::\n\n\nWe want to model race times (`net`) based on runner characteristics `runner` and age `age`. We'll use $Y_{i,j}$ to refer to race times and $X_{i,j}$ to refer to age, where $i$ refers individual races and $j$ refers to runners.\n\n\n# 17.1: First steps: Complete pooling\n\nWe'll start by recreating the complete pooling model from chapter 15:\n\n$$\n\\begin{aligned}\n\\text{Race time}_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\beta_0 + \\beta_1\\, \\text{Age}_i \\\\\n\\\\\n\\beta_0 &\\sim \\mathcal{N}(0, 35) \\\\\n\\beta_1 &\\sim \\mathcal{N}(0, 2.5) \\\\\n\\sigma &\\sim \\operatorname{Exponential}(1/10)\n\\end{aligned}\n$$\n\nI'll just do it in brms here—for rstanarm, go look at either the book or [my notes for chapter 15](/bayes-rules/15-chapter.qmd#complete-pooling)\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors <- c(prior(normal(0, 35), class = Intercept),\n            prior(normal(0, 2.5), class = b),\n            prior(exponential(0.1), class = sigma))\n\nmodel_complete_pooling_brms <- brm(\n  bf(net ~ age),\n  data = running,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, iter = 4000, seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0,\n  file = \"17-manual_cache/complete-pooling-brms\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(model_complete_pooling_brms, effects = \"fixed\", conf.level = 0.8)\n## # A tibble: 2 × 7\n##   effect component term        estimate std.error conf.low conf.high\n##   <chr>  <chr>     <chr>          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 fixed  cond      (Intercept)   75.2      24.6     43.1     107.   \n## 2 fixed  cond      age            0.267     0.447   -0.306     0.850\n```\n:::\n\n\n\n\nAgain, this isn't the best model ever. It ignores within-runner trends in age. It implies that running time increases by 0.27 minutes for each additional year runners age, but with an 80% credible interval of -0.31–0.85 minutes. That means there's no substantial relationship between age and race time, even though we'd assume that people get slower over time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_complete_pooling_brms |> \n  add_epred_draws(newdata = tibble(age = seq(min(running$age), \n                                             max(running$age), \n                                             length.out = 100))) |> \n  ggplot(aes(x = age, y = .epred)) +\n  geom_smooth(data = running,\n              aes(y = net, group = runner), method = \"lm\", se = FALSE, \n              color = \"grey60\", size = 0.5) +\n  stat_lineribbon(alpha = 0.25, fill = clrs[4], color = clrs[4]) +\n  labs(x = \"Age\", y = \"Race time\")\n## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n## ℹ Please use `linewidth` instead.\n## Warning: Using the `size` aesthietic with geom_ribbon was deprecated in ggplot2 3.4.0.\n## ℹ Please use the `linewidth` aesthetic instead.\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Warning: Using the `size` aesthietic with geom_line was deprecated in ggplot2 3.4.0.\n## ℹ Please use the `linewidth` aesthetic instead.\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n# 17.2: Hierarchical model with varying intercepts\n\nFirst we'll build a model that accounts for varying runner-specific average race times, but ignores runner-specific age trends in race times. That is, we'll assume one global age trend, but each runner will have their own intercept for that trend based on runner-specific characteristics.\n\nTo do this we need to think about all three layers involved in this model:\n\n- Running times within each runner $j$\n- How average running times vary between runners\n- Global parameters like average running time, variance, etc.\n\n## Layer 1: Variability within runners\n\nIn this first layer, we can say that each runner's race time varies around their mean ($\\mu_{i,j}$) with some within-runner variability $\\sigma_y$. In previous chapters, we've just looked at $\\mu_j$ as an average (average running time; average popularity), but we can actually model it using a linear model and incorporate age effects, resulting in a model like this:\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) \\\\\n\\mu_{i_j} &= \\beta_{0_j} + \\beta_1 X_{i_j}\n\\end{aligned}\n$$\n\nWith this layer of the model, we have a few parameters:\n\n- $\\beta_{0_j}$ is the runner-specific intercept for runner $j$. It is group-specific.\n- $\\beta_1$ is the global coefficient (i.e. no subscripts) for the effect of age on race time. It is global and shared across all runners.\n- $\\sigma_y$ is the within-runner variability for the regression model. It measures the strength of the relationship between an individual runner's age and their race time. It is also global and shared across all runners.\n\n## Layer 2: Variability between runners\n\nNext we need to think about the variability between runners. With only random intercepts, we're just going to worry about $\\beta_0$ in this stage.\n\n$$\n\\beta_{0_j} \\sim \\mathcal{N}(\\beta_0, \\sigma_0)\n$$\n\nWe have two parameters here:\n\n- $\\beta_0$ is the global average intercept across all runners, or the average runner's race time\n- $\\sigma_0$ is the between-runner variability around that global average, or how much race times bounce around the average\n\n## Layer 3: Global priors\n\nFinally we need priors for all the global parameters on the righthand side of these different layers:\n\n- $\\beta_0$: Average race time for all runners\n- $\\beta_1$: Effect of age on race time for all runners\n- $\\sigma_y$: Within-runner variability of race time\n- $\\sigma_0$: Between-runner variability of average runner race time\n\n## Combined model\n\nPhew. With all these pieces, we can present the final formal model:\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) & \\text{Race times within runners } j \\\\\n\\mu_{i_j} &= \\beta_{0_j} + \\beta_1 X_{i_j} & \\text{Linear model of within-runner variation} \\\\\n\\beta_{0_j} &\\sim \\mathcal{N}(\\beta_0, \\sigma_0) & \\text{Variability in average times between runners} \\\\\n\\\\\n\\beta_0 &\\sim \\text{Some prior} & \\text{Global priors} \\\\\n\\beta_1 &\\sim \\text{Some prior} \\\\\n\\sigma_y &\\sim \\text{Some prior} \\\\\n\\sigma_0 &\\sim \\text{Some prior}\n\\end{aligned}\n$$\n\n## Other way of writing all this: offsets\n\nWe can also think about the between-runner variation as a series of offsets from the global mean, which I find easier to conceptualize (and the inner workings of brms treat them this way, since running `ranef()` gets you these offsets). Here, each runner-specific intercept is a combination of the global average and a runner-specific offset from that average:\n\n$$\n\\beta_{0_j} = \\beta_0 + b_{0_j}\n$$\n\nThese offsets come from a normal distribution with some standard deviation $\\sigma_0$:\n\n$$\nb_{0_j} \\sim \\mathcal{N}(0, \\sigma_0)\n$$\n\nWe can add these offsets directly to the model:\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) & \\text{Race times within runners } j \\\\\n\\mu_{i_j} &= (\\beta_0 + b_{0_j}) + \\beta_1 X_{i_j} & \\text{Linear model of within-runner variation} \\\\\nb_{0_j} &\\sim \\mathcal{N}(0, \\sigma_0) & \\text{Random runner offsets} \\\\\n\\\\\n\\beta_0 &\\sim \\text{Some prior} & \\text{Global priors} \\\\\n\\beta_1 &\\sim \\text{Some prior} \\\\\n\\sigma_y &\\sim \\text{Some prior} \\\\\n\\sigma_0 &\\sim \\text{Some prior}\n\\end{aligned}\n$$\n\n## Prior simulation\n\nIt's been a few chapters since we've done this, but it's a good idea to set specific priors and then simulate from them to see if they're reasonable. (In previous chapters the book used rstanarm's magical autoscale thing; I chose my own reasonableish priors, but never simulated from them. Also, back in chapter 15 we didn't center the intercept, but here we will because it makes interpretation and prior setting easier.)\n\nHere's the reasoning they go through in the book:\n\n- A typical runner in this age group runs between an 8-minute and 12-minute mile, and the race is 10 miles, so average race time should be 80–120 minutes, so we'll use $\\mathcal{N}(100, 10)$\n- We think that race times increase as age increases. In the book they say it's probably somewhere between 0.5–4.5 minutes a year, so $\\mathcal{N}(2.5, 1)$\n- For the variability between runners ($\\sigma_0$, or the offsets) and the variability within runners ($\\sigma_y$), we don't know much, other than the fact that they have to be positive. We'll say that they vary moderately with a standard deviation of 10 minutes, so we'll use $\\operatorname{Exponential}(1/10)$\n\nThat leaves us with this official model:\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) & \\text{Race times within runners } j \\\\\n\\mu_{i_j} &= (\\beta_{0c} + b_{0_j}) + \\beta_1 X_{i_j} & \\text{Linear model of within-runner variation} \\\\\nb_{0_j} &\\sim \\mathcal{N}(0, \\sigma_0) & \\text{Random runner offsets} \\\\\n\\\\\n\\beta_{0_c} &\\sim \\mathcal{N}(100, 10) & \\text{Prior for global average} \\\\\n\\beta_1 &\\sim \\mathcal{N}(2.5, 1) & \\text{Prior for global age effect} \\\\\n\\sigma_y &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for within-runner variability} \\\\\n\\sigma_0 &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for between-runner variability}\n\\end{aligned}\n$$\n\nAnd here's what these priors look like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot() +\n  stat_function(fun = ~dnorm(., 100, 10),\n                geom = \"area\", fill = clrs[1]) +\n  xlim(c(60, 140)) +\n  labs(x = \"**β<sub>0c</sub>**<br>Global average runner race time\") +\n  theme(axis.title.x = element_markdown(), axis.text.y = element_blank(), \n        axis.title.y = element_blank(), axis.ticks.y = element_blank(),\n        panel.grid = element_blank())\n\np2 <- ggplot() +\n  stat_function(fun = ~dnorm(., 2.5, 1),\n                geom = \"area\", fill = clrs[2]) +\n  xlim(c(-1, 6)) +\n  labs(x = \"**β<sub>1</sub>**<br>Global effect of age on race time\") +\n  theme(axis.title.x = element_markdown(), axis.text.y = element_blank(), \n        axis.title.y = element_blank(), axis.ticks.y = element_blank(),\n        panel.grid = element_blank())\n\np3 <- ggplot() +\n  stat_function(fun = ~dexp(., 1/10),\n                geom = \"area\", fill = clrs[3]) +\n  xlim(c(0, 60)) +\n  labs(x = \"**σ<sub>y</sub>** and **σ<sub>0</sub>**<br>Variation *within* individuals' race times<br>and *between* average runner race times\") +\n  theme(axis.title.x = element_markdown(), axis.text.y = element_blank(), \n        axis.title.y = element_blank(), axis.ticks.y = element_blank(),\n        panel.grid = element_blank())\n\np1 | p2 | p3\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-6-1.png){width=816}\n:::\n:::\n\n\nLet's simulate these priors, both with brms and with rstanarm:\n\n::: {.panel-tabset}\n### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors <- c(prior(normal(100, 10), class = Intercept),\n            prior(normal(2.5, 1), class = b),\n            prior(exponential(0.1), class = sigma),\n            prior(exponential(0.1), class = sd))\n\nmodel_running1_brms_prior <- brm(\n  net ~ age_c + (1 | runner), \n  data = running,\n  family = gaussian(),\n  prior = priors,\n  sample_prior = \"only\",\n  chains = 4, cores = 4, iter = 4000, threads = threading(2), seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0,\n  file = \"17-manual_cache/running1-brms-prior\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- running |> \n  add_predicted_draws(model_running1_brms_prior, ndraws = 100) |> \n  ggplot(aes(x = .prediction, group = .draw)) +\n  geom_density(size = 0.25, color = clrs[3]) +\n  labs(x = \"Predicted race time\", y = \"Density\") +\n  coord_cartesian(xlim = c(-100, 300))\n\np2 <- running |> \n  add_linpred_draws(model_running1_brms_prior, ndraws = 6, \n                    seed = 12345) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = paste(runner, .draw)),\n            color = clrs[1], size = 0.25) +\n  labs(x = \"Age\", y = \"Race time\") +\n  coord_cartesian(ylim = c(50, 130)) +\n  facet_wrap(vars(.draw))\n\n(p1 | p2) + plot_layout(widths = c(0.3, 0.7))\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n\n### rstanarm\n\n\n::: {.cell hash='17-chapter_cache/html/model-running1-rstanarm-prior_3d1be84839a7c7e54550e269afda8b11'}\n\n```{.r .cell-code}\nmodel_running1_rstanarm_prior <- stan_glmer(\n  net ~ age_c + (1 | runner), \n  data = running, family = gaussian,\n  prior_intercept = normal(100, 10),\n  prior = normal(2.5, 1), \n  prior_aux = exponential(1, autoscale = TRUE),\n  prior_covariance = decov(reg = 1, conc = 1, shape = 1, scale = 1),\n  chains = 4, cores = 4, iter = 5000*2, seed = 84735, refresh = 0,\n  prior_PD = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- running |> \n  add_predicted_draws(model_running1_rstanarm_prior, ndraws = 100) |> \n  ggplot(aes(x = .prediction, group = .draw)) +\n  geom_density(size = 0.25, color = clrs[3]) +\n  labs(x = \"Predicted race time\", y = \"Density\") +\n  coord_cartesian(xlim = c(-100, 300))\n\np2 <- running |> \n  add_linpred_draws(model_running1_rstanarm_prior, ndraws = 6, \n                    seed = 12345) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = paste(runner, .draw)),\n            color = clrs[1], size = 0.25) +\n  labs(x = \"Age\", y = \"Race time\") +\n  coord_cartesian(ylim = c(50, 130)) +\n  facet_wrap(vars(.draw))\n\n(p1 | p2) + plot_layout(widths = c(0.3, 0.7))\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-8-1.png){width=768}\n:::\n:::\n\n\n:::\n\nThe plots from these prior simulations show us 100 plausible sets of overall race times, as well as six sets of 36 simulated runners. The race time predictions are all plausible-looking, clustered around 100 minutes with most variation between 50 and 150 minutes. The repeated 36 runners also look okay—the relationship between age and race time is consistently positive and never super steep, and there's good random variation across the intercepts, as expected.\n\n\n## Posterior simulation and analysis\n\nActual posterior time!\n\n::: {.panel-tabset}\n### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors <- c(prior(normal(100, 10), class = Intercept),\n            prior(normal(2.5, 1), class = b),\n            prior(exponential(0.1), class = sigma),\n            prior(exponential(0.1), class = sd))\n\nmodel_running1_brms <- brm(\n  net ~ age_c + (1 | runner), \n  data = running,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, iter = 4000, threads = threading(2), seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0,\n  file = \"17-manual_cache/running1-brms\"\n)\n```\n:::\n\n\n### rstanarm\n\n\n::: {.cell hash='17-chapter_cache/html/model-running1-rstanarm_85b306bd6482ea91a4a0503718c61cf7'}\n\n```{.r .cell-code}\nmodel_running1_rstanarm <- stan_glmer(\n  net ~ age_c + (1 | runner), \n  data = running, family = gaussian,\n  prior_intercept = normal(100, 10),\n  prior = normal(2.5, 1), \n  prior_aux = exponential(1, autoscale = TRUE),\n  prior_covariance = decov(reg = 1, conc = 1, shape = 1, scale = 1),\n  chains = 4, cores = 4, iter = 5000*2, seed = 84735, refresh = 0)\n```\n:::\n\n:::\n\n### Global analysis\n\nFirst we'll look at the relationship between running time and age for the *typical* runner. This involves just the global $\\beta_0$ and the global $\\beta_1$, which don't have any group-specific elements.\n\n::: {.panel-tabset}\n\n#### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_brms |> \n  tidy(effects = c(\"fixed\"), conf.level = 0.8) |> \n  select(-component)\n## # A tibble: 2 × 6\n##   effect term        estimate std.error conf.low conf.high\n##   <chr>  <chr>          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 fixed  (Intercept)    90.8      2.13     88.0      93.5 \n## 2 fixed  age_c           1.30     0.219     1.02      1.58\n```\n:::\n\n\n\n\n#### rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_rstanarm |> \n  tidy(effects = c(\"fixed\"),\n       conf.int = TRUE, conf.level = 0.8)\n## # A tibble: 2 × 5\n##   term        estimate std.error conf.low conf.high\n##   <chr>          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 (Intercept)    90.6      2.17     87.8      93.5 \n## 2 age_c           1.30     0.219     1.02      1.58\n```\n:::\n\n\n:::\n\nWe've got two coefficients to interpret:\n\n- $\\beta_0$ is 90.77 is the overall global posterior mean race time for all runners. There's an 80% chance that it's between 88.03 and 93.48 minutes.\n- $\\beta_1$ shows that a typical runner slows down by a posterior mean of 1.3 minutes each year. There's an 80% chance that the effect is between 1.02 and 1.58 minutes, which definitely isn't zero, so we're pretty confident that there's a \"significant\" and substantial age effect.\n\nHere's what this posterior relationship looks like. Again, this is for a *typical* runner.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_brms |> \n  linpred_draws(running, ndraws = 200, re_formula = NA) |> \n  ggplot(aes(x = age, y = net)) +\n  stat_lineribbon(aes(y = .linpred), fill = clrs[4], color = clrs[4], alpha = 0.2) +\n  labs(x = \"Age\", y = \"Race time\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nThis is neat! When we pooled all the data together, we didn't have any \"significant\" effect. After taking runner-specific characteristics into account, we found an actual substantial, practical effect.\n\n\n### Runner-specific analysis\n\nNext we can explore the model's group details by looking at the different runner specific offsets from the global $\\beta_0$ mean, or the different $b_{0_j}$ terms:\n\n$$\n\\beta_0 + b_{0_j}\n$$\n\nFirst, we can look at just the intercepts and how much they differ from the global mean. Runner 10 is exceptionally slow compared to the general average; Runners 29 and 30 are exceptionally fast:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_b0 <- model_running1_brms |> \n  tidy(effects = c(\"fixed\"), conf.level = 0.8) |> \n  filter(term == \"(Intercept)\")\n\nrunning1_runner_offsets <- model_running1_brms |> \n  spread_draws(b_Intercept, r_runner[runner,]) |> \n  mutate(runner_intercept = b_Intercept + r_runner) |> \n  ungroup() |> \n  mutate(runner = fct_reorder(factor(runner), runner_intercept, .fun = mean))\n\n# Instead of manually adding the offsets to the intercept, we could also use\n# posterior_linpred() to calculate the linear predictions for each runner when\n# all other covariates are set to 0; the results are identical\n# running1_runner_offsets <- model_running1_brms |> \n#   linpred_draws(tibble(runner = unique(running$runner),\n#                        age_c = 0)) |> \n#   ungroup() |> \n#   mutate(runner = fct_reorder(factor(runner), .linpred, .fun = mean))\n\nrunning1_runner_offsets |> \n  ggplot(aes(x = runner_intercept, y = runner)) +\n  annotate(geom = \"rect\", ymin = -Inf, ymax = Inf,\n           xmin = global_b0$conf.low, xmax = global_b0$conf.high,\n           fill = clrs[2], alpha = 0.4) +\n  geom_vline(xintercept = global_b0$estimate, color = clrs[2]) +\n  stat_pointinterval(color = clrs[3])\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nNext we can see how these runner-specific offsets influence the age-race time relationship. In the book they compare posterior linear predictions for runners 4 and 5. Just shifting the intercept around helps a lot with model fit!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunning |> \n  filter(runner %in% c(\"4\", \"5\")) |> \n  add_linpred_draws(model_running1_brms, ndraws = 100) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = paste(runner, .draw), color = runner),\n            size = 0.3, alpha = 0.2) +\n  geom_point(aes(color = runner)) +\n  scale_color_manual(values = c(clrs[3], clrs[6])) +\n  labs(x = \"Age\", y = \"Race time\", color = \"Runner\")\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nFinally, the book plots the posterior median slope and intercepts for all 36 runners. Most runners' lines are clustered around the global median, as expected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunning1_all_runner_lines <- model_running1_brms |> \n  linpred_draws(expand_grid(runner = unique(running$runner),\n                            age_c = c(50 - unscaled$age_c$scaled_center,\n                                      61 - unscaled$age_c$scaled_center))) |> \n  group_by(runner, age_c) |> \n  median_qi(.linpred) |> \n  mutate(age = age_c + unscaled$age_c$scaled_center)\n\nrunning1_global_trend <- running1_all_runner_lines |> \n  group_by(age_c) |> \n  median_qi(.linpred) |> \n  mutate(age = age_c + unscaled$age_c$scaled_center)\n\nrunning1_all_runner_lines |> \n  ggplot(aes(x = age, y = .linpred)) +\n  geom_line(aes(group = runner), color = \"grey70\") +\n  geom_line(data = running1_global_trend, color = clrs[5], size = 2) +\n  coord_cartesian(ylim = c(50, 135))\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/plot-running1-lines-1.png){width=672}\n:::\n:::\n\n\n### Within- and between-runner variability\n\nFinally we can look at the two $\\sigma$ terms: $\\sigma_y$ (`sd__Observation`) for the variability within runners and $\\sigma_0$ (`sd__(Intercept)` for the `runner` group) for the variability between runners' baseline averages, or the variability around the $b_{0_j}$ offsets.\n\n::: {.panel-tabset}\n\n#### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_brms |> \n  tidy(effects = c(\"ran_pars\"), conf.level = 0.8) |> \n  select(-component)\n## # A tibble: 2 × 7\n##   effect   group    term            estimate std.error conf.low conf.high\n##   <chr>    <chr>    <chr>              <dbl>     <dbl>    <dbl>     <dbl>\n## 1 ran_pars runner   sd__(Intercept)    13.5      1.65     11.5      15.6 \n## 2 ran_pars Residual sd__Observation     5.21     0.306     4.83      5.62\n```\n:::\n\n\n#### rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_rstanarm |> \n  tidy(effects = c(\"ran_pars\"),\n       conf.int = TRUE, conf.level = 0.8)\n## # A tibble: 2 × 3\n##   term                    group    estimate\n##   <chr>                   <chr>       <dbl>\n## 1 sd_(Intercept).runner   runner      13.4 \n## 2 sd_Observation.Residual Residual     5.25\n```\n:::\n\n\n:::\n\nThe $\\sigma_y$ (or `sd__Observation`) term here is 5.21, which means that within any runner, their race times vary by 5 minutes around their individual race time average. \n\n$\\sigma_0$ (or `sd__(Intercept)` for the `runner` group) on the other hand, is 13.48, which means that average runner speeds vary or bounce around by 13 minutes across runners. There's thus more variation between runners than within individual runners.\n\nIf we square these terms and make ratios of the values, we can see how much of the total model variation comes from within-runner and between-runner variation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running1_brms |> \n  tidy(effects = c(\"ran_pars\"), conf.int = FALSE) |> \n  select(-component, -effect, -std.error) |> \n  mutate(sigma_2 = estimate^2) |> \n  mutate(props = sigma_2 / sum(sigma_2))\n## # A tibble: 2 × 5\n##   group    term            estimate sigma_2 props\n##   <chr>    <chr>              <dbl>   <dbl> <dbl>\n## 1 runner   sd__(Intercept)    13.5    182.  0.870\n## 2 Residual sd__Observation     5.21    27.2 0.130\n```\n:::\n\n\n\n\nNeat! 87% of the variability in race times comes from between-runner differences, while 13% comes from variations within individual runners.\n\nWe can also use `performance::icc()` to calculate this ratio automatically:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance::icc(model_running1_brms, by_group = TRUE)\n## # ICC by Group\n## \n## Group  |   ICC\n## --------------\n## runner | 0.870\n```\n:::\n\n\n\n# 17.3: Hierarchical model with varying intercepts & slopes\n\nFun times so far, and even funner times ahead. \n\nHowever, we've just been working with varying intercepts, assuming that the relationship between age and speed is the same for each runner. In reality, though, that's not the case. Some runners slow down faster or slower over time—some even get faster as they age. If we compare this random-intercepts-only model to the actual trends in the data we can see that we've missed those varying runner effects—every runner in the right panel here is perfectly parallel. To capture these different age-race relationships within runners, we can use both random intercepts *and* random slopes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- running |> \n  ggplot(aes(x = age, y = net, group = runner)) + \n  geom_smooth(method = \"lm\", se = FALSE, size = 0.5, color = clrs[1]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = \"Race time\",\n       title = \"Observed data\",\n       subtitle = \"Basic per-runner OLS models\")\n\np2 <- running |> \n  add_linpred_draws(model_running1_brms, ndraws = 100) |> \n  summarize(.linpred = mean(.linpred)) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = runner),\n            size = 0.5, color = clrs[3]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = \"Race time\", \n       title = \"Random intercepts only\",\n       subtitle = \"Posterior means\")\n\np1 | p2\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n## Model building\n\nGetting random slopes into the model requires some tinkering with the formal model structure\n\nWith layer 1 (within-runner variation), we now use $\\beta_{1_j}$ instead of the global $\\beta_1$ term from before, showing that each runner $j$ gets their own $\\beta_1$:\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) \\\\\n\\mu_{i_j} &= \\beta_{0_j} + \\beta_{1_j} X_{i_j}\n\\end{aligned}\n$$\n\nIn the non-offset-based syntax, we can then say that both $\\beta_{0_j}$ and $\\beta_{1_j}$ follow some random distribution with coefficient-specific variance ($\\sigma_0$ and $\\sigma_1$ now instead of just $\\sigma_0$):\n\n$$\n\\begin{aligned}\n\\beta_{0_j} \\sim \\mathcal{N}(\\beta_0, \\sigma_0) \\\\\n\\beta_{1_j} \\sim \\mathcal{N}(\\beta_1, \\sigma_1)\n\\end{aligned}\n$$\n\nLife gets a little trickier with these terms, though, because $\\beta_{0_j}$ and $\\beta_{1_j}$ are correlated and move together within each runner. So instead of writing the models for $\\beta_{0_j}$ and $\\beta_{1_j}$ as two separate lines, we have to consider them together:\n\n\n$$\n\\left(\n  \\begin{array}{c} \n  \\beta_{0_j} \\\\\n  \\beta_{1_j}\n  \\end{array}\n\\right) \n\\sim \\mathcal{N}\n\\left( \n  \\left(\n    \\begin{array}{c}\n    \\beta_0 \\\\\n    \\beta_1 \\\\\n    \\end{array}\n  \\right)\n  , \\,\\Sigma\n\\right)\n$$\n\nWritten like this, we can draw values for $\\beta_{0_j}$ and $\\beta_{1_j}$ from a multivariate (or joint) normal distribution with a shared covariance $\\Sigma$, which includes both the variability and the correlation between $\\beta_{0_j}$ and $\\beta_{1_j}$:\n\n$$\n\\Sigma = \n\\left(\n  \\begin{array}{cc}\n     \\text{Var}_{\\beta_0} & \\text{Cov}_{\\beta_0, \\beta_1} \\\\ \n     \\text{Cov}_{\\beta_0, \\beta_1} & \\text{Var}_{\\beta_1}\n  \\end{array}\n\\right)\n$$\n\nWe can transform the variance term into Greek letters by replacing $\\text{Var}_{\\beta_0}$ with $\\sigma^2_{\\beta_0}$. The covariance term can change to $\\sigma_{\\beta_0, \\beta_1}$, but that's a little trickier to work with because thinking about covariance values is less intuitive than thinking about standard deviations or correlation. So to make life easier, we can do a little algebra to rewrite the covariance as a function of the correlation $\\rho_{\\beta_0, \\beta_1}$ and the two standard deviations $\\sigma_{\\beta_0}$ and $\\sigma_{\\beta_1}$. \n\n$$\n\\begin{aligned}\n\\rho_{\\beta_0, \\beta_1} &= \\frac{\\sigma_{\\beta_0, \\beta_1}}{\\sigma_{\\beta_0} \\sigma_{\\beta_0}} \\\\\n\\sigma_{\\beta_0, \\beta_1} &= \\rho_{\\beta_0, \\beta_1}\\, \\sigma_{\\beta_0} \\sigma_{\\beta_0}\n\\end{aligned}\n$$\n\nThat leaves us with this fun mess (with the lower triangle omitted because it's repeated, and because that's what @ODeaNobleNakagawa:2021 do in their neat overview-of-multilevel-models paper):\n\n$$\n\\Sigma = \n\\left(\n  \\begin{array}{cc}\n     \\sigma^2_{\\beta_0} & \\rho_{\\beta_0, \\beta_1}\\, \\sigma_{\\beta_0} \\sigma_{\\beta_1} \\\\ \n     \\dots & \\sigma^2_{\\beta_1}\n  \\end{array}\n\\right)\n$$\n\nIn *Bayes Rules!* they simplify this more by getting rid of the $\\beta$s in the subscripts:\n\n$$\n\\Sigma = \n\\left(\n  \\begin{array}{cc}\n     \\sigma^2_{0} & \\rho_{0, 1}\\, \\sigma_{0} \\sigma_{1} \\\\ \n     \\dots & \\sigma^2_{1}\n  \\end{array}\n\\right)\n$$\n\nThis matrix has the two $\\sigma_0$ and $\\sigma_1$ terms that control the variability in $\\beta_{0_j}$ and $\\beta_{1_j}$, and it also has a messy new $\\rho_{0, 1}\\, \\sigma_{0} \\sigma_{1}$ term for the correlation between $\\beta_{0_j}$ and $\\beta_{1_j}$\n\nIn *Bayes Rules!* they show some plots with simulated data that demonstrate what this correlation actually means. They don't include the code for it, so I'll make up my own version here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwithr::with_seed(123, {\n  rho_plots <- tibble(rho = c(-0.99, 0, 0.99)) |> \n    mutate(title = glue::glue(\"ρ = {rho}\"),\n           subtitle = c(\"Strong negative correlation\\nbetween slope and intercept\",\n                        \"No correlation\\nbetween slope and intercept\",\n                        \"Strong positive correlation\\nbetween slope and intercept\")) |> \n    mutate(Sigma = map(rho, ~matrix(c(1, .x, .x, 1), 2, 2))) |> \n    mutate(data = map(Sigma, ~{\n      MASS::mvrnorm(n = 100, mu = c(2, 3), Sigma = .x) |> \n        as_tibble() |> \n        rename(b0 = V1, b1 = V2)\n    })) |> \n    mutate(plot = pmap(list(data, title, subtitle), ~{\n      ggplot(..1) +\n        geom_abline(aes(intercept = b0, slope = b1, color = b0),\n                    size = 0.3) +\n        scale_color_viridis_c(option = \"rocket\", begin = 0.1, end = 0.85,\n                              limits = c(-1, 5)) +\n        labs(title = ..2, subtitle = ..3, color = \"β<sub>0</sub>\") +\n        lims(x = c(0, 3), y = c(0, 10)) +\n        coord_axes_inside() +\n        theme(axis.line = element_line(),\n              legend.title = element_markdown())\n    }))\n})\n\nwrap_plots(rho_plots$plot) + \n  plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-21-1.png){width=100%}\n:::\n:::\n\n\nWhen $\\rho$ is negative, bigger intercepts have smaller slopes. In the context of runners, this would mean that individual runners who have longer baseline race time averages would see less of an age effect. When $\\rho$ is negative, bigger intercepts have steeper slopes—individual runners with longer baseline race times would see a stronger age effect.\n\nSOO with all that, here's what the final formal model with varying intercepts and slopes looks like:\n\n::: {.column-page-inset}\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) & \\text{Race times within runners } j \\\\\n\\mu_{i_j} &= \\beta_{0_j} + \\beta_{1_j} X_{i_j} & \\text{Linear model of within-runner variation} \\\\\n\\left(\n  \\begin{array}{c} \n  \\beta_{0_j} \\\\\n  \\beta_{1_j}\n  \\end{array}\n\\right) \n&\\sim \\mathcal{N}\n\\left( \n  \\left(\n    \\begin{array}{c}\n    \\beta_0 \\\\\n    \\beta_1 \\\\\n    \\end{array}\n  \\right)\n  , \\,\n  \\left(\n  \\begin{array}{cc}\n     \\sigma^2_{0} & \\rho_{0, 1}\\, \\sigma_{0} \\sigma_{1} \\\\ \n     \\dots & \\sigma^2_{1}\n  \\end{array}\n\\right)\n\\right) & \\text{Variability in average runner intercepts and slopes} \\\\\n\\\\\n\\beta_{0_c} &\\sim \\mathcal{N}(100, 10) & \\text{Prior for global average} \\\\\n\\beta_1 &\\sim \\mathcal{N}(2.5, 1) & \\text{Prior for global age effect} \\\\\n\\sigma_y &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for within-runner variability} \\\\\n\\sigma_0 &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for between-runner intercept variability} \\\\\n\\sigma_1 &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for between-runner slope variability} \\\\\n\\rho &\\sim \\operatorname{LKJ}(1) & \\text{Prior for between-runner variability} \n\\end{aligned}\n$$\n\n:::\n\nWe can also write this using offset-based notation:\n\n::: {.column-page-inset}\n\n$$\n\\begin{aligned}\nY_{i_j} &\\sim \\mathcal{N}(\\mu_{i_j}, \\sigma_y) & \\text{Race times within runners } j \\\\\n\\mu_{i_j} &= (\\beta_{0c} + b_{0_j}) + (\\beta_1 + b_{1_j}) X_{i_j} & \\text{Linear model of within-runner variation} \\\\\n\\left(\n  \\begin{array}{c} \n  b_{0_j} \\\\\n  b_{1_j}\n  \\end{array}\n\\right) \n&\\sim \\mathcal{N}\n\\left( \n  \\left(\n    \\begin{array}{c}\n    0 \\\\\n    0 \\\\\n    \\end{array}\n  \\right)\n  , \\,\n  \\left(\n  \\begin{array}{cc}\n     \\sigma^2_{0} & \\rho_{0, 1}\\, \\sigma_{0} \\sigma_{1} \\\\ \n     \\dots & \\sigma^2_{1}\n  \\end{array}\n\\right)\n\\right) & \\text{Variability in average runner intercepts and slopes} \\\\\n\\\\\n\\beta_{0_c} &\\sim \\mathcal{N}(100, 10) & \\text{Prior for global average} \\\\\n\\beta_1 &\\sim \\mathcal{N}(2.5, 1) & \\text{Prior for global age effect} \\\\\n\\sigma_y &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for within-runner variability} \\\\\n\\sigma_0 &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for between-runner intercept variability} \\\\\n\\sigma_1 &\\sim \\operatorname{Exponential}(1/10) & \\text{Prior for between-runner slope variability} \\\\\n\\rho &\\sim \\operatorname{LKJ}(1) & \\text{Prior for between-runner variability} \n\\end{aligned}\n$$\n\n:::\n\nThere's one new thing here in the priors—we need to set a prior for the correlation of the slopes and intercepts, or $\\rho_{0,1}$. This can get *really* complex. *Bayes Rules!* has [a whole optional section](https://www.bayesrulesbook.com/chapter-17.html#optional-the-decomposition-of-covariance-model) showing how it's possible to decompose the $\\Sigma$ covariance matrix into three component parts:\n\n- $R$, or a regularization hyperparameter\n- $\\tau$, or the total standard deviation in the intercepts and slopes\n- $\\pi_0$ and $\\pi_1$, or the relative proportion of the variability between groups that comes from differing intercepts and slopes\n\nThat's a *ton* of fine tuning! You can set these priors in rstanarm like so:\n\n```r\nstan_glmer(\n  ...\n  prior_covariance = decov(reg = 1, conc = 1, shape = 1, scale = 1),\n  ...\n)\n```\n\nbrms makes this a lot easier (though the `lkj()` prior lets you set all these decomposed parts too!) and only makes you set a prior for the $\\rho$ term by itself, or the `cor` class here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_prior(\n  net ~ age_c + (1 + age_c | runner), \n  data = running,\n  family = gaussian()\n)\n##                     prior     class      coef  group resp dpar nlpar lb ub       source\n##                    (flat)         b                                             default\n##                    (flat)         b     age_c                              (vectorized)\n##                    lkj(1)       cor                                             default\n##                    lkj(1)       cor           runner                       (vectorized)\n##  student_t(3, 89.4, 14.2) Intercept                                             default\n##     student_t(3, 0, 14.2)        sd                                   0         default\n##     student_t(3, 0, 14.2)        sd           runner                  0    (vectorized)\n##     student_t(3, 0, 14.2)        sd     age_c runner                  0    (vectorized)\n##     student_t(3, 0, 14.2)        sd Intercept runner                  0    (vectorized)\n##     student_t(3, 0, 14.2)     sigma                                   0         default\n```\n:::\n\n\nThis just needs to be a value between -1 and 1, like a regular correlation coefficient. By default, brms uses an LKJ distribution, which is a strange beast that ranges between -1 and 1. There's no built-in function like `dlkj()`, and I haven't found a comparable function in other packages like **extraDistr**, but **tidybayes** supports it! \n\nThe LKJ distribution takes one hyperparameter $\\eta$ that controls the shape:\n\n- When $\\eta < 1$, extreme correlations are more likely\n- When $\\eta = 1$, all correlations are equally likely\n- When $\\eta > 1$, central correlations are more likely, and the larger the $\\eta$, the narrower the distribution is around 0\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(eta = c(0.5, 1, 5, 15)) |> \n  mutate(prior = glue::glue(\"lkjcorr({eta})\")) |>\n  mutate(prior_nice = fct_inorder(glue::glue(\"LKJ(η = {eta})\"))) |> \n  parse_dist(prior) |> \n  marginalize_lkjcorr(K = 2) |>  # K = dimension of correlation matrix; ours is 2x2 here\n  ggplot(aes(y = 0, dist = .dist, args = .args)) +\n  stat_slab(fill = clrs[5]) +\n  labs(x = \"**ρ**<br>Correlation between β<sub>0</sub> and β<sub>1</sub>\") +\n  theme(axis.title.x = element_markdown(), axis.text.y = element_blank(), \n        axis.title.y = element_blank(), axis.ticks.y = element_blank(),\n        panel.grid = element_blank()) +\n  facet_wrap(vars(prior_nice), nrow = 1)\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n## Posterior simulation and analysis\n\nWe'll skip the prior simulation and go right to model fitting and exploring the posterior.\n\n::: {.panel-tabset}\n### brms\n\nBump up the `adapt_delta` to help with convergence here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npriors <- c(prior(normal(100, 10), class = Intercept),\n            prior(normal(2.5, 1), class = b),\n            prior(exponential(0.1), class = sigma),\n            prior(exponential(0.1), class = sd),\n            prior(lkj(1), class = cor))\n\nmodel_running2_brms <- brm(\n  net ~ age_c + (1 + age_c | runner), \n  data = running,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, iter = 4000, threads = threading(2), seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0, control = list(adapt_delta = 0.9),\n  file = \"17-manual_cache/running2-brms\"\n)\n```\n:::\n\n\n### rstanarm\n\n\n::: {.cell hash='17-chapter_cache/html/model-running2-rstanarm_e261b600e41c5586102e7926d6e84ddf'}\n\n```{.r .cell-code}\nmodel_running2_rstanarm <- stan_glmer(\n  net ~ age_c + (1 + age_c | runner), \n  data = running, family = gaussian,\n  prior_intercept = normal(100, 10),\n  prior = normal(2.5, 1), \n  prior_aux = exponential(1, autoscale = TRUE),\n  prior_covariance = decov(reg = 1, conc = 1, shape = 1, scale = 1),\n  chains = 4, cores = 4, iter = 5000*2, seed = 84735, refresh = 0, adapt_delta = 0.9)\n```\n:::\n\n:::\n\nHoly moly we have a bunch of things we can work with now—78 different parameters! 36 runner-specific intercept offsets, 36 runner-specific slope offsets, and 6 global terms. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_variables(model_running2_brms)\n##  [1] \"b_Intercept\"                  \"b_age_c\"                      \"sd_runner__Intercept\"        \n##  [4] \"sd_runner__age_c\"             \"cor_runner__Intercept__age_c\" \"sigma\"                       \n##  [7] \"r_runner[1,Intercept]\"        \"r_runner[2,Intercept]\"        \"r_runner[3,Intercept]\"       \n## [10] \"r_runner[4,Intercept]\"        \"r_runner[5,Intercept]\"        \"r_runner[6,Intercept]\"       \n## [13] \"r_runner[7,Intercept]\"        \"r_runner[8,Intercept]\"        \"r_runner[9,Intercept]\"       \n## [16] \"r_runner[10,Intercept]\"       \"r_runner[11,Intercept]\"       \"r_runner[12,Intercept]\"      \n## [19] \"r_runner[13,Intercept]\"       \"r_runner[14,Intercept]\"       \"r_runner[15,Intercept]\"      \n## [22] \"r_runner[16,Intercept]\"       \"r_runner[17,Intercept]\"       \"r_runner[18,Intercept]\"      \n## [25] \"r_runner[19,Intercept]\"       \"r_runner[20,Intercept]\"       \"r_runner[21,Intercept]\"      \n## [28] \"r_runner[22,Intercept]\"       \"r_runner[23,Intercept]\"       \"r_runner[24,Intercept]\"      \n## [31] \"r_runner[25,Intercept]\"       \"r_runner[26,Intercept]\"       \"r_runner[27,Intercept]\"      \n## [34] \"r_runner[28,Intercept]\"       \"r_runner[29,Intercept]\"       \"r_runner[30,Intercept]\"      \n## [37] \"r_runner[31,Intercept]\"       \"r_runner[32,Intercept]\"       \"r_runner[33,Intercept]\"      \n## [40] \"r_runner[34,Intercept]\"       \"r_runner[35,Intercept]\"       \"r_runner[36,Intercept]\"      \n## [43] \"r_runner[1,age_c]\"            \"r_runner[2,age_c]\"            \"r_runner[3,age_c]\"           \n## [46] \"r_runner[4,age_c]\"            \"r_runner[5,age_c]\"            \"r_runner[6,age_c]\"           \n## [49] \"r_runner[7,age_c]\"            \"r_runner[8,age_c]\"            \"r_runner[9,age_c]\"           \n## [52] \"r_runner[10,age_c]\"           \"r_runner[11,age_c]\"           \"r_runner[12,age_c]\"          \n## [55] \"r_runner[13,age_c]\"           \"r_runner[14,age_c]\"           \"r_runner[15,age_c]\"          \n## [58] \"r_runner[16,age_c]\"           \"r_runner[17,age_c]\"           \"r_runner[18,age_c]\"          \n## [61] \"r_runner[19,age_c]\"           \"r_runner[20,age_c]\"           \"r_runner[21,age_c]\"          \n## [64] \"r_runner[22,age_c]\"           \"r_runner[23,age_c]\"           \"r_runner[24,age_c]\"          \n## [67] \"r_runner[25,age_c]\"           \"r_runner[26,age_c]\"           \"r_runner[27,age_c]\"          \n## [70] \"r_runner[28,age_c]\"           \"r_runner[29,age_c]\"           \"r_runner[30,age_c]\"          \n## [73] \"r_runner[31,age_c]\"           \"r_runner[32,age_c]\"           \"r_runner[33,age_c]\"          \n## [76] \"r_runner[34,age_c]\"           \"r_runner[35,age_c]\"           \"r_runner[36,age_c]\"          \n## [79] \"lprior\"                       \"lp__\"                         \"accept_stat__\"               \n## [82] \"treedepth__\"                  \"stepsize__\"                   \"divergent__\"                 \n## [85] \"n_leapfrog__\"                 \"energy__\"\n```\n:::\n\n\nLike we did with the random intercepts model, we'll look at all of these in turn.\n\n### Global analysis\n\nFirst we'll look at the relationship between running time and age for the *typical* runner, or just the global $\\beta_0$ and the global $\\beta_1$.\n\n::: {.panel-tabset}\n\n#### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  tidy(effects = c(\"fixed\"), conf.level = 0.8) |> \n  select(-component)\n## # A tibble: 2 × 6\n##   effect term        estimate std.error conf.low conf.high\n##   <chr>  <chr>          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 fixed  (Intercept)    90.9      2.28     88.1      93.8 \n## 2 fixed  age_c           1.36     0.253     1.05      1.68\n```\n:::\n\n\n\n\n#### rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_rstanarm |> \n  tidy(effects = c(\"fixed\"),\n       conf.int = TRUE, conf.level = 0.8)\n## # A tibble: 2 × 5\n##   term        estimate std.error conf.low conf.high\n##   <chr>          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 (Intercept)    90.9      2.11     88.2      93.7 \n## 2 age_c           1.37     0.263     1.04      1.72\n```\n:::\n\n\n:::\n\nInterpretation time: \n\n- $\\beta_0$ is 90.94 is the overall global posterior mean race time for all runners. There's an 80% chance that it's between 88.1 and 93.76 minutes.\n- $\\beta_1$ shows that a typical runner slows down by a posterior mean of 1.36 minutes each year. There's an 80% chance that the effect is between 1.05 and 1.68 minutes, which is \"significant\" and substantial. It's also really close to the 1.3-year effect we found with just random intercepts.\n\nLet's plot it for fun. Again, this is for a *typical* runner and incorporates no group-level information at all (hence `re_formula = NA)`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  linpred_draws(running, ndraws = 200, re_formula = NA) |> \n  ggplot(aes(x = age, y = net)) +\n  stat_lineribbon(aes(y = .linpred), fill = clrs[4], color = clrs[4], alpha = 0.2) +\n  labs(x = \"Age\", y = \"Race time\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n### Runner-specific analysis\n\nWe could hypothetically extract and visualize all the runner-specific offsets to the slopes and intercepts (with `ranef()`), but we'll skip that here and instead look at the runner-specific lines. Each line here is constructed using a unique set of $\\beta_{0_j}$ and $\\beta_{1_j}$ terms for each runner, each based around the global $\\beta_0$ and $\\beta_1$ estimates. To help with the intuition, here are the lines some of the runners:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  spread_draws(b_Intercept, b_age_c, r_runner[runner, term]) |> \n  pivot_wider(names_from = \"term\", values_from = r_runner) |> \n  mutate(runner_intercept = b_Intercept + Intercept,\n         runner_age = b_age_c + age_c) |> \n  group_by(runner) |> \n  summarize(across(c(runner_intercept, runner_age), ~median(.)))\n## # A tibble: 36 × 3\n##    runner runner_intercept runner_age\n##     <int>            <dbl>      <dbl>\n##  1      1             76.7      0.584\n##  2      2             85.3      1.21 \n##  3      3             91.4      1.11 \n##  4      4            102.       1.56 \n##  5      5             78.3      1.20 \n##  6      6             75.2      0.892\n##  7      7            104.       1.64 \n##  8      8            104.       1.76 \n##  9      9             96.6      1.63 \n## 10     10            114.       2.21 \n## # … with 26 more rows\n```\n:::\n\n\nWe can plot these to see them easier. In the book they plot these with `geom_abline()` to go across the whole range of the plot. We can also limit the lines to each runners' observed ages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunning2_all_runner_lines <- model_running2_brms |> \n  linpred_draws(expand_grid(runner = unique(running$runner),\n                            age_c = c(50 - unscaled$age_c$scaled_center,\n                                      61 - unscaled$age_c$scaled_center))) |> \n  group_by(runner, age_c) |> \n  median_qi(.linpred) |> \n  mutate(age = age_c + unscaled$age_c$scaled_center)\n\nrunning |> \n  add_linpred_draws(model_running2_brms) |> \n  summarize(.linpred = mean(.linpred)) |> \n  ggplot(aes(x = age, y = .linpred)) +\n  geom_line(data = running2_all_runner_lines, \n            aes(group = runner), color = \"grey70\", size = 0.25) +\n  geom_line(aes(y = .linpred, group = runner),\n            size = 0.75, color = clrs[6]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = \"Race time\")\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n### Within- and between-runner variability\n\nFinally we can look at all the $\\sigma$ terms. We have a bunch now:\n\n- $\\sigma_y$ (`sd__Observation`): the variability within runners \n- $\\sigma_0$ (`sd__(Intercept)` for the `runner` group): the variability between runners' baseline averages, or the variability around the $b_{0_j}$ offsets\n- $\\sigma_1$ (`sd__age_c` for the `runner` group): the variability between runners' age effects, or the variability around the $b_{1_j}$ offsets\n\n::: {.panel-tabset}\n\n#### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  tidy(effects = c(\"ran_pars\"), conf.level = 0.8) |> \n  select(-component)\n## # A tibble: 4 × 7\n##   effect   group    term                   estimate std.error conf.low conf.high\n##   <chr>    <chr>    <chr>                     <dbl>     <dbl>    <dbl>     <dbl>\n## 1 ran_pars runner   sd__(Intercept)          13.3       1.70   11.2       15.5  \n## 2 ran_pars runner   sd__age_c                 0.796     0.355   0.324      1.25 \n## 3 ran_pars runner   cor__(Intercept).age_c    0.474     0.303   0.0991     0.829\n## 4 ran_pars Residual sd__Observation           5.04      0.325   4.63       5.47\n```\n:::\n\n\n#### rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_rstanarm |> \n  tidy(effects = c(\"ran_pars\"),\n       conf.int = TRUE, conf.level = 0.8)\n## # A tibble: 4 × 3\n##   term                         group    estimate\n##   <chr>                        <chr>       <dbl>\n## 1 sd_(Intercept).runner        runner     12.9  \n## 2 sd_age_c.runner              runner      0.989\n## 3 cor_(Intercept).age_c.runner runner      0.447\n## 4 sd_Observation.Residual      Residual    5.03\n```\n:::\n\n\n:::\n\n- $\\sigma_y$ (or `sd__Observation`) is 5.04, which means that within any runner, their race times vary by 5 minutes around their individual race time average. \n- $\\sigma_0$ (or `sd__(Intercept)` for the `runner` group) is 13.25, which means that average runner speeds vary or bounce around by 13 minutes across runners. \n- $\\sigma_1$ (or `sd__age_c` for the `runner` group) is 0.8, which means that average age effects vary by 0.8 minutes across runners. \n\nWe could try to decompose this variation by squaring these $\\sigma$s and calculating ratios, but with random slopes, the math for this gets too hard if we want to incorporate slope information or details from additional groups (if we had another grouping level). `performance::icc()` even yells at us about it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance::icc(model_running2_brms, by_group = TRUE)\n## Warning: Model contains random slopes. Cannot compute accurate ICCs by group factors.\n## # ICC by Group\n## \n## Group  |   ICC\n## --------------\n## runner | 0.859\n```\n:::\n\n\nWe can look at the overall ICC instead, which tells us the percent of the total variation that comes from between-runner differences\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance::icc(model_running2_brms, by_group = FALSE)\n## # Intraclass Correlation Coefficient\n## \n##     Adjusted ICC: 0.878\n##   Unadjusted ICC: 0.838\n```\n:::\n\n\nFinally, we also have an estimate for $\\rho$ (`cor__(Intercept).age_c` for the `runner` group), or the correlation between the runner-specific slopes and intercepts. Here it's 0.47, which seems large! And substantially different from what the book has (-0.09). That's weird. I think it's because I'm using the centered version of age here and they don't, so the intercept term is on a different scale in my models? Also, I'm not too concerned—brms provides credible intervals for this $\\rho$ term (rstanarm doesn't seem to?), and there's an 80% chance that the correlation between the runner-specific slopes and intercepts is between 0.1 and 0.83, which is a huge window.\n\nContrary to the book, then, it seems that runners that start slower slow down faster over time. For fun, we can look at the relationship between $\\rho$ and $\\beta_{0_j}$ for each runner. It's positive—as the intercept increases, the correlation between the intercept and slope increases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrunning2_slope_int_cor <- model_running2_brms |> \n  spread_draws(b_Intercept, b_age_c, r_runner[runner, term]) |> \n  pivot_wider(names_from = \"term\", values_from = r_runner) |> \n  mutate(runner_intercept = b_Intercept + Intercept,\n         runner_age = b_age_c + age_c) |> \n  group_by(runner) |> \n  summarize(correlation = cor(runner_intercept, runner_age),\n            across(c(runner_intercept, runner_age), ~median(.)))\n\nrunning2_slope_int_cor |> \n  ggplot(aes(x = runner_intercept, y = correlation)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = clrs[1]) +\n  labs(x = \"β<sub>0<sub>j</sub></sub>\", y = \"ρ\") +\n  theme(axis.title.x = element_markdown())\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\n# 17.4: Model evaluation & selection\n\nPhew we've done a ton of modeling work here, with a completely pooled model, a model with just random intercepts, and a model with random intercepts and random slopes. They all fit the data in different ways:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- running |> \n  add_linpred_draws(model_complete_pooling_brms, ndraws = 100) |> \n  summarize(.linpred = mean(.linpred)) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = runner),\n            size = 1, color = clrs[2]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = \"Race time\", \n       title = \"Completely pooled model\")\n\np2 <- running |> \n  add_linpred_draws(model_running1_brms, ndraws = 100) |> \n  summarize(.linpred = mean(.linpred)) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = runner),\n            size = 0.5, color = clrs[3]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = NULL, \n       title = \"Random intercepts only\")\n\np3 <- running |> \n  add_linpred_draws(model_running2_brms, ndraws = 100) |> \n  summarize(.linpred = mean(.linpred)) |> \n  ggplot(aes(x = age, y = net)) +\n  geom_line(aes(y = .linpred, group = runner),\n            size = 0.5, color = clrs[6]) +\n  coord_cartesian(ylim = c(60, 125)) +\n  labs(x = \"Age\", y = NULL, \n       title = \"Random intercepts and slopes\")\n\np1 | p2 | p3\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-36-1.png){width=912}\n:::\n:::\n\n\nTo evaluate which of these is best, we need to ask our three questions:\n\n## 1: How fair is each model?\n\nThey're all equally fair and good.\n\n## 2: How wrong is each model?\n\nFor this we can look at posterior predictive checks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- pp_check(model_complete_pooling_brms, ndraws = 25, type = \"dens_overlay\") +\n  labs(x = \"Running time\", title = \"Completely pooled model\") +\n  guides(color = \"none\") +\n  coord_cartesian(xlim = c(45, 135))\n\np2 <- pp_check(model_running1_brms, ndraws = 25, type = \"dens_overlay\") +\n  labs(x = \"Running time\", title = \"Random intercepts only\") +\n  guides(color = \"none\") +\n  coord_cartesian(xlim = c(45, 135))\n\np3 <- pp_check(model_running2_brms, ndraws = 25, type = \"dens_overlay\") +\n  labs(x = \"Running time\", title = \"Random intercepts and slopes\") + \n  coord_cartesian(xlim = c(45, 135))\n\np1 | p2 | p3\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-37-1.png){width=912}\n:::\n:::\n\n\nThe models with the random effects definitely fit the underlying data better, but it doesn't look like there's a huge difference between the random intercepts-only model and the model with random intercepts and slopes.\n\nWe also know from earlier that the models give different estimates for the age effect. In the pooled model it's not \"significant\"; in the multilevel models it is.\n\n\n## 3: How accurate are each model's predictions?\n\nIn *Bayes Rules!* they look at predictive accuracy a few different ways: mean average predictions, k-fold cross validation, and ELPD/LOO values. I'm going to skip those first two because they don't play nicely with brms models and instead just look at ELPD. There's no huge difference between the predictive densities. Based on that, the *Bayes Rules!* authors conclude by choosing the model with random intercepts only, mostly for the sake of parsimony and simplicity. Adding the random slopes doesn't really help with the estimates or the accuracy (though it does make prettier pictures), so it's best to work with a simpler version of the model with fewer moving parts to worry about.\n\n\n::: {.cell hash='17-chapter_cache/html/loo-stats_aebd77f02a94f577e90a240fe1ff4579'}\n\n```{.r .cell-code}\nloo_stats <- tribble(\n  ~model_name, ~model,\n  \"Completely pooled model\", model_complete_pooling_brms,\n  \"Random intercepts only\", model_running1_brms,\n  \"Random intercepts and slopes\", model_running2_brms\n) |> \n  mutate(loo = map(model, ~loo(.))) |> \n  mutate(loo_stuff = map(loo, ~as_tibble(.$estimates, rownames = \"statistic\"))) |> \n  select(model_name, loo_stuff) |> \n  unnest(loo_stuff) |> \n  filter(statistic == \"elpd_loo\") |> \n  arrange(desc(Estimate))\nloo_stats\n## # A tibble: 3 × 4\n##   model_name                   statistic Estimate    SE\n##   <chr>                        <chr>        <dbl> <dbl>\n## 1 Random intercepts and slopes elpd_loo     -589. 18.0 \n## 2 Random intercepts only       elpd_loo     -590. 17.5 \n## 3 Completely pooled model      elpd_loo     -753.  8.69\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nloo_stats |> \n  mutate(model_name = fct_rev(fct_inorder(model_name))) |> \n  ggplot(aes(x = Estimate, y = model_name)) +\n  geom_pointrange(aes(xmin = Estimate - 2 * SE, xmax = Estimate + 2 * SE)) +\n  labs(x = \"ELPD\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nloo_compare(loo(model_complete_pooling_brms),\n            loo(model_running1_brms), \n            loo(model_running2_brms))\n##                             elpd_diff se_diff\n## model_running2_brms            0.0       0.0 \n## model_running1_brms           -0.5       3.1 \n## model_complete_pooling_brms -163.4      17.5\n```\n:::\n\n\n\n# 17.5: Posterior prediction\n\nLike we did in chapter 16, we can use the posteriors here to generate predictions, both for existing runners and for completely new runners. We'll use `posterior_predict()` (technically its **tidybayes** wrapper `predicted_draws()`) with `re_formula = NULL` to incorporate the random effects, `allow_new_levels` to allow it to make predictions for Miles, and `sample_new_levels = \"gaussian\"` to draw the random offsets in slopes and intercepts from a normal distribution.\n\nNote how the predictions for Miles here are really wide. We don't know much about him, so the predictions really just reflect a bunch of randomness around the global mean race time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  predicted_draws(tibble(runner = c(\"1\", \"Miles\", \"10\"),\n                         age_c = 61 - unscaled$age_c$scaled_center),\n                  re_formula = NULL, allow_new_levels = TRUE,\n                  sample_new_levels = \"gaussian\") |> \n  ungroup() |> \n  mutate(runner = fct_inorder(runner)) |> \n  ggplot(aes(x = .prediction, y = runner, fill = runner)) +\n  scale_fill_manual(values = c(clrs[1], clrs[3], clrs[6])) +\n  stat_halfeye() +\n  labs(x = \"Predicted race time\", y = NULL, fill = \"Runner\")\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\nSince we modeled it as a random effect, we can also do some neat things with the age effect in the posterior predictions. Runner 1's time doesn't really change as they age; Runner 10 slows down substantially over time. Miles has a slight increase in running time over the years, since the effect is really just a bunch of randomness around the global $\\beta_1$ effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_running2_brms |> \n  predicted_draws(expand_grid(runner = c(\"1\", \"Miles\", \"10\"),\n                              age_c = seq(50, 62, by = 2) - unscaled$age_c$scaled_center),\n                  re_formula = NULL, allow_new_levels = TRUE,\n                  sample_new_levels = \"gaussian\") |> \n  mutate(age = age_c + unscaled$age_c$scaled_center) |> \n  ungroup() |> \n  mutate(runner = fct_inorder(runner)) |> \n  ggplot(aes(x = .prediction, y = factor(age), fill = runner)) +\n  scale_fill_manual(values = c(clrs[1], clrs[3], clrs[6]), guide = \"none\") +\n  stat_slab(height = 2, slab_color = \"white\", slab_size = 0.25) +\n  labs(x = \"Predicted race time\", y = \"Age\", fill = \"Runner\") +\n  facet_wrap(vars(runner)) +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](17-chapter_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n\n# 17.6: Spotify and dancibility\n\nHOLY COW this chapter has been long and difficult and I'm tired. In the book they do one more example with the Spotify data with two models:\n\n- `danceability ~ valence + genre + (1 | artist)`\n- `danceability ~ valence + genre + (valence | artist)`\n\nI'm not going to recreate their stuff with brms here (for now; maybe someday I'll come back and do that). [See that section for complete details.](https://www.bayesrulesbook.com/chapter-17.html#example-danceability)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}