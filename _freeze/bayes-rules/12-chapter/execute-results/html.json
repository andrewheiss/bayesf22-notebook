{
  "hash": "24077aff47b6ad74a3c84510ea73e56f",
  "result": {
    "markdown": "---\ntitle: \"12: Poisson & negative binomial regression\"\nsubtitle: \"Reading notes\"\ndate: \"October 7, 2022\"\n---\n\n\n[(Original chapter)](https://www.bayesrulesbook.com/chapter-12.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bayesrules)\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(cmdstanr)\nlibrary(rstanarm)\nlibrary(marginaleffects)\nlibrary(broom)\nlibrary(broom.mixed)\nlibrary(tidybayes)\nlibrary(ggdist)\nlibrary(patchwork)\nlibrary(ggh4x)  # For coord_axes_inside() and nested facets\nlibrary(geomtextpath)\nlibrary(ggrepel)\nlibrary(extraDistr)\n\n# Plot stuff\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Tell bayesplot to use the Lakota palette for things like pp_check()\n# bayesplot::color_scheme_set(clrs)\n\n# Tell bayesplot to use the viridis rocket palette for things like pp_check()\nviridisLite::viridis(6, option = \"rocket\", end = 0.85, direction = -1) |> \n  # Take off the trailing \"FF\" in the hex codes\n  map_chr(~str_sub(., 1, 7)) |> \n  bayesplot::color_scheme_set()\n\n# Seed stuff\nset.seed(1234)\nBAYES_SEED <- 1234\n\ndata(equality_index, package = \"bayesrules\")\n\nequality <- equality_index |> \n  # Omit California because it has so many laws already\n  filter(state != \"california\")\n```\n:::\n\n\n# The general setup\n\nWe want to model the number of LGBTQ+ anti-discrimination laws in states based on how urban a state is and its historical partisan voting patterns. Here's the general relationship. A regular straight OLS line doesn't fit the data well, but because the outcome is a count, and because the general relationship is curvy, Poisson regression will work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(equality, aes(x = percent_urban, y = laws)) +\n  geom_point(aes(fill = historical), pch = 21, size = 4, color = \"white\") +\n  geom_smooth(aes(color = \"Poisson regression\"), se = FALSE, method = \"glm\", \n              method.args = list(family = \"poisson\")) +\n  geom_smooth(aes(color = \"Normal regression\"), se = FALSE, method = \"lm\") +\n  scale_fill_manual(values = c(clrs[6], clrs[3], clrs[2])) +\n  scale_color_manual(values = c(clrs[5], clrs[4])) +\n  labs(x = \"Percent urban\", y = \"Count of laws\", color = NULL, fill = \"Party\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n# 12.1: Building the Poisson regression model\n\n## Prelude: Intuition behind GLM links\n\nIn Poisson models, the $\\lambda$ rate must be positive. But if you model $\\lambda$ with a regression model like\n\n$$\n\\lambda_i = \\beta_0 + \\beta_1 X_{i1} + \\beta_2 X_{i2} + \\dots, \n$$\n\nthe predicted values for $\\lambda$ could be negative. So instead we can force $\\lambda$ to be positive by using a log link function, or\n\n$$\n\\log(\\lambda_i) = \\beta_0 + \\beta_1 X_{i1} + \\beta_2 X_{i2} + \\dots\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- augment(lm(laws ~ percent_urban + historical, data = equality), \n              newdata = expand_grid(percent_urban = seq(0, 100, 1),\n                                    historical = c(\"dem\", \"gop\", \"swing\"))) |> \n  ggplot(aes(x = percent_urban, y = .fitted, color = historical)) +\n  geom_textline(aes(label = historical), linewidth = 1, hjust = 0.7) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2]), guide = \"none\") +\n  labs(x = \"Percent urban\", y = \"Predicted count of laws\",\n       title = \"Linear model of laws\", subtitle = \"Model predicts negative laws\") +\n  theme_minimal() +\n  theme(axis.line = element_line(),\n        legend.position = \"bottom\") +\n  coord_axes_inside()\n\np2 <- augment(glm(laws ~ percent_urban + historical, data = equality,\n                  family = poisson(link = \"log\")), \n              newdata = expand_grid(percent_urban = seq(0, 100, 1),\n                                    historical = c(\"dem\", \"gop\", \"swing\")),\n              type.predict = \"link\") |> \n  ggplot(aes(x = percent_urban, y = .fitted, color = historical)) +\n  geom_textline(aes(label = historical), linewidth = 1, hjust = 0.7) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2]), guide = \"none\") +\n  labs(x = \"Percent urban\", y = \"Predicted count of laws (log scale)\",\n       title = \"Poisson model of laws, log scale\",\n       subtitle = \"Log link forces λ to be > 0\") +\n  theme_minimal() +\n  theme(axis.line = element_line(),\n        legend.position = \"bottom\") +\n  coord_axes_inside(ylim = c(0, 4))\n\np3 <- augment(glm(laws ~ percent_urban + historical, data = equality,\n                  family = poisson(link = \"log\")), \n              newdata = expand_grid(percent_urban = seq(0, 100, 1),\n                                    historical = c(\"dem\", \"gop\", \"swing\")),\n              type.predict = \"response\") |> \n  ggplot(aes(x = percent_urban, y = .fitted, color = historical)) +\n  geom_textline(aes(label = historical), linewidth = 1, hjust = 0.7) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2]), guide = \"none\") +\n  labs(x = \"Percent urban\", y = \"Predicted count of laws\",\n       title = \"Poisson model of laws, response scale\",\n       subtitle = \"Backtransformed link keeps predictions above 0\") +\n  theme_minimal() +\n  theme(axis.line = element_line(),\n        legend.position = \"bottom\") +\n  coord_axes_inside(ylim = c(0, 30))\n\np1 | p2 | p3\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-3-1.png){width=1152}\n:::\n:::\n\n\n\n## Prelude II: How to interpret Poisson coefficients\n\nBefore specifying priors, it's helpful to know what these actual coefficients mean. Here's a basic frequentist model, with coefficients logged and exponentiated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_basic <- glm(laws ~ percent_urban + historical, data = equality,\n                   family = poisson(link = \"log\"))\ntidy(model_basic)\n## # A tibble: 4 × 5\n##   term            estimate std.error statistic  p.value\n##   <chr>              <dbl>     <dbl>     <dbl>    <dbl>\n## 1 (Intercept)       1.72     0.305        5.65 1.62e- 8\n## 2 percent_urban     0.0163   0.00357      4.56 5.15e- 6\n## 3 historicalgop    -1.51     0.135      -11.2  4.39e-29\n## 4 historicalswing  -0.609    0.105       -5.78 7.52e- 9\ntidy(model_basic, exponentiate = TRUE)\n## # A tibble: 4 × 5\n##   term            estimate std.error statistic  p.value\n##   <chr>              <dbl>     <dbl>     <dbl>    <dbl>\n## 1 (Intercept)        5.60    0.305        5.65 1.62e- 8\n## 2 percent_urban      1.02    0.00357      4.56 5.15e- 6\n## 3 historicalgop      0.220   0.135      -11.2  4.39e-29\n## 4 historicalswing    0.544   0.105       -5.78 7.52e- 9\n```\n:::\n\n\n- For the intercept $\\beta_0$, this is the intercept on the logged scale when percent urban is 0 in historically Democratic states (since it's the omitted base case). We can backtransform this to the response/count scale by exponentiating it: $e^{1.7225} = 5.599$. That means that in a historically Democratic non-urban state, we'd expect to see 5.6 anti-discrimination laws.\n\n    But the most un-urban Democratic states are Maine and Vermont, each at 38% urban, so the intercept isn't super important here.\n\n- For the percent urban $\\beta_1$ coefficient, this is the slope of the line on the log scale. We can expect the logged number of laws in states to increase by 0.0163 for every additional percentage point of urban-ness. To make that more interpretable we can exponentiate it ($e^{0.0163} = 1.0164$), which means that a 1 percentage point increase in urban-ness is associated with 1.0164 times more anti-discrimination laws (or 1.64%)\n\n- For the party/`historical` $\\beta_2$ and $\\beta_3$ coefficients, these are the shifts in the logged Democratic intercept (again because it's the omitted base case). We'd thus expect the logged number of laws in GOP states to be 1.5 lower on average. That makes no sense when logged, but if we exponentiate it ($e^{-1.5145} = 0.2199$), we find that GOP states should have 22% as many anti-discrimination laws as a Democratic state (or only 22% of what a typical Democratic state would have).\n\nOr even better, we can look at the [average marginal effects](https://www.andrewheiss.com/blog/2022/05/20/marginalia/) for these coefficients and get an overall average slope and change in intercept across the whole range of the fitted line. Here, the average slope is 0.17 laws (not logged laws) as urban-ness increases; the average GOP difference is 14.7 laws (that's huge!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_basic <- marginaleffects(model_basic)\ntidy(mfx_basic)\n##       type          term    contrast    estimate  std.error  statistic\n## 1 response percent_urban       dY/dX   0.1718771 0.03894868   4.412913\n## 2 response    historical   gop - dem -14.7199505 1.33083188 -11.060714\n## 3 response    historical swing - dem  -8.6083989 1.47239777  -5.846517\n##        p.value     conf.low   conf.high\n## 1 1.019892e-05   0.09553912   0.2482152\n## 2 1.945431e-28 -17.32833305 -12.1115680\n## 3 5.019718e-09 -11.49424546  -5.7225522\n```\n:::\n\n\n…or we can look at the [average marginal effects at user-specified or representative values](https://www.andrewheiss.com/blog/2022/05/20/marginalia/#average-marginal-effects-at-counterfactual-user-specified-values), like in prototypical urban and rural Democratic and Republican states:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_basic_typical <- model_basic |> \n  marginaleffects(newdata = datagrid(percent_urban = c(40, 90),\n                                     historical = c(\"dem\", \"gop\")),\n                  variables = \"percent_urban\",\n                  by = c(\"percent_urban\", \"historical\"))\ntidy(mfx_basic_typical)\n##       type          term    contrast percent_urban historical   estimate\n## 1 response percent_urban mean(dY/dX)            40        dem 0.17440682\n## 2 response percent_urban mean(dY/dX)            40        gop 0.03835624\n## 3 response percent_urban mean(dY/dX)            90        dem 0.39318726\n## 4 response percent_urban mean(dY/dX)            90        gop 0.08647131\n##     std.error statistic      p.value   conf.low  conf.high\n## 1 0.015033937 11.600875 4.078865e-31 0.14494084 0.20387279\n## 2 0.006152249  6.234507 4.532025e-10 0.02629806 0.05041443\n## 3 0.098768546  3.980896 6.865611e-05 0.19960447 0.58677006\n## 4 0.027393506  3.156635 1.596007e-03 0.03278103 0.14016159\n```\n:::\n\n\nThis is neat! For Democratic states the backtransformed slope/effect is fairly large: a one percentage point increase (or rather, an infinitely small increase, since we're working with instantaneous partial derivatives here), is associated with 0.17 more anti-discrimination laws in rural states and 0.39 in urban states. In Republican states, the effect is small, with 0.04 and 0.09 more laws in rural and urban states.\n\n## Prelude III: Poisson assumptions\n\nPoisson models have a few important assumptions: \n\n1. **Structure of the data**: Conditioned on predictors $X$, the observed data $Y_i$ for each case $i$ is independent of other cases like case $j$\n2. **Structure of $Y$**: The outcome is a discrete count of events\n3. **Structure of the relationship**: The logged average $Y$ value can be written as a linear combination of the predictors: $\\log(\\lambda_i) = \\beta_0 + \\beta_1 X_{i1} + \\dots$\n4. **Structure of the variability in $Y$**: The mean and variance in Poisson distributions is the same, so there should be more spread around the fitted line for higher values of $Y$\n\nThe first three are all straightforward and standard for GLM-type models: $Y$ needs to be independent, $Y$ needs to be a count, and $\\log(Y)$ has to be modelable with a linear model.\n\nThe fourth is unique to Poisson models, though. In the Poisson distribution, the mean and the variance are the same thing, both when looking at $Y$ by itself and when conditioning it on other things:\n\n$$\n\\begin{aligned}\nE(Y) &= \\operatorname{Var}(Y) = \\lambda \\text{, and} \\\\\nE(Y \\mid X) &= \\operatorname{Var}(Y \\mid X) = \\lambda\n\\end{aligned}\n$$\n\nWe can check that with the count of laws, both overall:\n\n$$\nE(\\text{Laws}) = \\operatorname{Var}(\\text{Laws})\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality |> \n  summarise(mean = mean(laws),\n            variance = sd(laws))\n## # A tibble: 1 × 2\n##    mean variance\n##   <dbl>    <dbl>\n## 1  10.6     10.3\n```\n:::\n\n\nAnd across different levels of urban-ness:\n\n$$\nE(\\text{Laws} \\mid \\text{Percent urban}) = \\operatorname{Var}(\\text{Laws}\\mid \\text{Percent urban})\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_across_urban <- equality |> \n  mutate(urban_bins = santoku::chop_quantiles(percent_urban, \n                                              c(0.25, 0.5, 0.75))) |> \n  group_by(urban_bins) |> \n  summarise(mean = mean(laws),\n            variance = sd(laws)) |> \n  mutate(percent_urban = quantile(equality$percent_urban, c(0, 0.25, 0.5, 0.75) + 0.125), \n         .after = urban_bins)\nequality_across_urban\n## # A tibble: 4 × 4\n##   urban_bins  percent_urban  mean variance\n##   <fct>               <dbl> <dbl>    <dbl>\n## 1 [0%, 25%)            56.7  6.17     6.22\n## 2 [25%, 50%)           70.2  3.5      3.03\n## 3 [50%, 75%]           77.9 12        9.37\n## 4 (75%, 100%]          90.6 20.5     11.5\n```\n:::\n\n\nThat's magical. In general, the assumptions hold pretty well. It gets a little off (underdispersed) for higher values of percent urban, but overall, the mean and variance are the same!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality |> \n  ggplot(aes(x = percent_urban, y = laws)) +\n  geom_point(size = 1, color = \"grey60\") +\n  geom_smooth(se = FALSE, method = \"glm\", method.args = list(family = \"poisson\"),\n              size = 0.5, color = \"grey40\") +\n  geom_pointrange(data = equality_across_urban, \n                  aes(y = mean, ymin = mean - variance, ymax = mean + variance),\n                  color = clrs[4])\n## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n## ℹ Please use `linewidth` instead.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Defining the priors\n\nOkay cool. Now that we've checked the Poisson assumptions and these coefficients make sense, we can set good logical priors for the different parameters in our Poisson model.\n\nFor our priors, we'll say that we think that number of anti-discrimination laws in a typical state is 7. The log of that is 2ish ($\\log(7) \\approx 1.95$). We'll also say that this logged intercept could range ±1 around that mean, so 1–3. In the unlogged world, that means a typical state would have between 3 and 20 laws ($e^1 \\approx 3; e^3 \\approx 20$). **Our prior for $\\beta_0$ is thus `normal(2, 0.5)`.**\n\nIn the book they specify a vague `normal(0, 2.5)` prior for all the other coefficients and rely on `rstanarm`'s autoscaling to make them reflect the data better. Here for fun I'll use brms to be more specific about the priors.\n\nFor urban-ness ($\\beta_1$), I think that there's definitely a positive relationship, but it's not going to be massive. A 10% increase in urban-ness in a typical state will probably add a couple more laws. The percent change from going from 7 (our prior intercept) to 9 is 0.3 ($\\frac{9 - 7}{7} = 0.286$). Scaling that down to the result of a 1% increase gives us a change of 0.0286, or if we think about it multiplicatively it would be 1.0286. The logged version of 1.0286 is 0.0282, so we're looking for coefficients around that. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(pct_change_10 <- (9 - 7) / 7)\n## [1] 0.2857143\n(pct_change_1 <- pct_change_10 * 0.1)\n## [1] 0.02857143\nlog(1 + pct_change_1)\n## [1] 0.02817088\n```\n:::\n\n\nTo get a sense for the range around that mean, let's pretend a typical state goes from 7 to 40 laws as it becomes a little bit more urban. That's a huge (and probably unlikely) jump! What does that look like in logged coefficients?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(pct_change_10 <- (40 - 7) / 7)\n## [1] 4.714286\n(pct_change_1 <- pct_change_10 * 0.1)\n## [1] 0.4714286\nlog(1 + pct_change_1)\n## [1] 0.3862337\n```\n:::\n\n\nAn effect that big would have a coefficient of 0.386. So in general, the range of plausible coefficients doesn't ever get too high. Like, a coefficient of 2 would imply that there would be 7.4 *times* the number of anti-discrimination laws (or an increase of 740%!) with just a 1 percentage point increase in urban-ness. That's wild.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(2)\n## [1] 7.389056\n```\n:::\n\n\nSo we'll set the prior average at 0, with a small range around it so that it goes from -2 to 2. For kicks and giggles, we'll use a t-distribution instead of a normal distribution since the t-distribution has fatter tails and makes large coefficients more possible (maybe some states do see huge jumps? idk). You can see the fatter tails here with the blue t-distribution. **Our official prior for $\\beta_1$ is thus `student_t(2, 0, 1)`.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R's built-in dt() function for t-distributions doesn't use mu and sigma, but\n# extraDistr::dlst() does. We'll set df arbitrarily to 2 here since that's what\n# McElreath did in his 7th video on robust regression :shrug:\nggplot() +\n  geom_function(fun = ~dlst(., df = 2, mu = 0, sigma = 1),\n                size = 1.5, color = clrs[1]) +\n  geom_function(fun = ~dnorm(., 0, 1), color = clrs[2], size = 0.5) +\n  xlim(c(-4, 4))\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nFor the party-specific changes in intercept ($\\beta_2$ and $\\beta_3$), we can conceptualize this as the number of GOP state laws as a percentage of Democratic laws. For example, we've already said that the typical zero-urban Democratic state has around 7 laws. Based on background knowledge of how GOP states have dealt with LGBTQ+ issues, I'm guessing that there's a big difference in those states. What if a GOP state has just one expected law? That would be 14% ($\\frac{1}{7} \\approx 0.143$) of a typical Democratic state. With 6 laws, it would have 86% as many laws ($\\frac{6}{7} \\approx 0.857$), and so on. We'll assume that GOP states on average will generally have fewer laws on average than Democratic states (meaning the ratio would be less than 1; if a GOP state had 8 laws compared to 7 in a Democratic state, the ratio would be 1.142). Let's say that on average GOP states will have 60% of the laws a Democratic state would—that would imply that compared to a Democratic state with 7 laws, a GOP state would have 4 ($7 \\times 0.6 = 4.2$). The ratio could be as low as 10%, and it could maybe be positive sometimes, like 110% or 150%, but it can never be below 0. Something like this half-t-distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(0.1, 5, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = 0.6, sigma = 2)) |>\n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[3]) +\n  geom_vline(xintercept = 1, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = 0.4, y = 0.05, \n           label = \"Fewer laws relative\\nto Democratic states\", size = 3) +\n  annotate(geom = \"label\", x = 1.6, y = 0.05, \n           label = \"More laws relative\\nto Democratic states\", size = 3) +\n  scale_x_continuous(labels = scales::percent_format(),\n                     breaks = seq(0, 5, 0.5)) +\n  labs(x = \"% of laws in identical Democratic state\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThat's cool, but we can't use that distribution in Stan because we're actually modelling the *logged* ratio. To get an idea of the general shape of the logged distribution we can log the t-distribution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(0.1, 6, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = 0.6, sigma = 2)) |>\n  mutate(x = log(x)) |> \n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[3]) +\n  geom_vline(xintercept = 0, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = -0.5, y = 0.05, \n           label = \"Fewer laws relative\\nto Democratic states\", size = 3) +\n  annotate(geom = \"label\", x = 0.5, y = 0.05, \n           label = \"More laws relative\\nto Democratic states\", size = 3)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nIt's doing some weird things on the left side of the plot because of how logs work with zero. The closer we get to 0, the bigger the logged value becomes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(0.1)\n## [1] -2.302585\nlog(0.01)\n## [1] -4.60517\nlog(0.00001)\n## [1] -11.51293\nlog(1e-10)\n## [1] -23.02585\n```\n:::\n\n\nIt's super unlikely that we'll ever see a GOP state with 0.00000001% of the laws of a Democratic state, so a value like -23 on the logged scale is super implausible. A GOP state with just 1% of the laws of a Democratic state would have a logged value of -4.6051702; any lower than that is extreme.\n\nSo our average of 0.6 is -0.511 on the log scale. We'll use a t-distribution again (for fat tails), and use a sigma of 2 which creates this kind of distribution with most values below 0 (so the unlogged ratio is less than 100%):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(-3, 2, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = log(0.6), sigma = 2)) |>\n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[3]) +\n  geom_vline(xintercept = 0, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = -0.7, y = 0.09, \n           label = \"Fewer laws relative\\nto Democratic states\", size = 3) +\n  annotate(geom = \"label\", x = 0.7, y = 0.09, \n           label = \"More laws relative\\nto Democratic states\", size = 3)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nThis still doesn't make a ton of sense with logged values, so we can exponentiate it just to see what it looks like on the original scale of ratios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(-3, 1, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = log(0.6), sigma = 2)) |>\n  mutate(x = exp(x)) |> \n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[3]) +\n  geom_vline(xintercept = 1, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = 0.7, y = 0.09, \n           label = \"Fewer laws relative\\nto Democratic states\", size = 3) +\n  annotate(geom = \"label\", x = 1.3, y = 0.09, \n           label = \"More laws relative\\nto Democratic states\", size = 3) +\n  scale_x_continuous(labels = scales::percent_format(),\n                     breaks = seq(0, 5, 0.5)) +\n  labs(x = \"% of laws in identical Democratic state\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nThat's not identical to the half-t-distribution we made up earlier, and it makes tiny ratios like 1% very unlikely, but the bulk of the distribution is still around 60% as expected, so we'll go with it. **Our final prior for $\\beta_2$ on the log scale is thus `student_t(2, -0.5, 2)`.**\n\nHistorical swing states behave a little differently. Some of them might have more laws than a typical Democratic state (like 8/7, or 1.14 or 114%); some might have fewer (like 6/7, or 0.86, or 86%). In this case we don't know much about the direction of the distance, so we'll say that the average ratio is 100% ± some amount:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(-2, 1.5, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = 0, sigma = 2)) |>\n  mutate(x = exp(x)) |> \n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[2]) +\n  geom_vline(xintercept = 1, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = 0.6, y = 0.11, \n           label = \"Fewer laws\\nrelative to\\nDemocratic\\nstates\", size = 3) +\n  annotate(geom = \"label\", x = 1.4, y = 0.11, \n           label = \"More laws\\nrelative to\\nDemocratic\\nstates\", size = 3) +\n  scale_x_continuous(labels = scales::percent_format(),\n                     breaks = seq(0, 5, 0.5)) +\n  labs(x = \"% of laws in identical Democratic state\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nOn a logged scale this nice and symmetrical around 0:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(x = seq(-2, 2, by = 0.01)) |> \n  mutate(y = dlst(x, df = 2, mu = 0, sigma = 2)) |>\n  ggplot(aes(x = x, y = y)) +\n  geom_line(size = 1, color = clrs[2]) +\n  geom_vline(xintercept = 0, color = \"grey50\", linetype = 21) +\n  annotate(geom = \"label\", x = -0.6, y = 0.11, \n           label = \"Fewer laws relative\\nto Democratic states\", size = 3) +\n  annotate(geom = \"label\", x = 0.6, y = 0.11, \n           label = \"More laws relative\\nto Democratic states\", size = 3)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nA `student_t(2, 0, 2)` distribution looks reasonable and vague enough, so **our final prior for $\\beta_3$ is `student_t(2, 0, 2)`.**\n\n## Finally, the formal model\n\nPHEW OKAY so with all of that, here's our official model and priors:\n\n$$\n\\begin{aligned}\n\\text{Laws}_i &\\sim \\operatorname{Poisson}(\\lambda_i) \\\\\n\\log(\\lambda_i) &= \\beta_0 + \\beta_1\\ \\text{Percent urban}_i + \\beta_2\\ \\text{GOP}_i + \\beta_3\\ \\text{Swing}_i \\\\\n\\\\\n\\beta_0 &\\sim \\mathcal{N}(2, 0.5) \\\\\n\\beta_1 &\\sim \\operatorname{Student t}(\\nu = 2, \\mu = 0, \\sigma = 1) \\\\\n\\beta_2 &\\sim \\operatorname{Student t}(\\nu = 2, \\mu = -0.5, \\sigma = 2) \\\\\n\\beta_3 &\\sim \\operatorname{Student t}(\\nu = 2, \\mu = 0, \\sigma = 2) \\\\\n\\end{aligned}\n$$\n\nHow reasonable are all these priors when they're all working together? Let's simulate it!\n\n::: {.panel-tabset}\n### brms\n\n\n::: {.cell hash='12-chapter_cache/html/model-laws-prior-only-brms_79e5bda3ad67dc801e06079aeff4d2b3'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(2, 0.5), class = Intercept),\n            prior(student_t(2, 0, 1), class = b, coef = \"percent_urban\"),\n            prior(student_t(2, -0.5, 2), class = b, coef = \"historicalgop\"),\n            prior(student_t(2, 0, 2), class = b, coef = \"historicalswing\"))\n\nmodel_equality_prior_brms <- brm(\n  bf(laws ~ percent_urban + historical),\n  data = equality,\n  family = poisson(),\n  prior = priors,\n  sample_prior = \"only\",\n  chains = 4, iter = 4000, seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0\n)\n## Start sampling\n```\n:::\n\n\nIt's all over the place with different slopes across different historical parties, which is good:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_draws_brms <- equality |> \n  group_by(historical) |> \n  summarize(min = min(percent_urban),\n            max = max(percent_urban)) |> \n  mutate(percent_urban = map2(min, max, ~seq(.x, .y, 1))) |> \n  unnest(percent_urban) |> \n  add_epred_draws(model_equality_prior_brms, ndraws = 100)\n\nprior_draws_brms |> \n  ggplot(aes(x = percent_urban, y = .epred)) +\n  geom_line(aes(group = paste(historical, .draw), color = historical), \n            alpha = 0.5, size = 0.5) +\n  coord_cartesian(ylim = c(0, 100)) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2])) +\n  labs(x = \"Percent urban\", y = \"Predicted number of laws\", color = \"Party\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### rstanarm\n\nWe can't specify individual parameter priors with rstanarm (???), so we'll just do what the book does and use `normal(0, 2.5)` with magical autoscaling:\n\n\n::: {.cell hash='12-chapter_cache/html/model-laws-prior-only-rstanarm_2e80950132b80a62d86e996ab46319f5'}\n\n```{.r .cell-code}\nequality_model_prior <- stan_glm(\n  laws ~ percent_urban + historical, \n  data = equality, \n  family = poisson,\n  prior_intercept = normal(2, 0.5),\n  prior = normal(0, 2.5, autoscale = TRUE), \n  chains = 4, iter = 4000, seed = 84735, refresh = 0,\n  prior_PD = TRUE\n)\n```\n:::\n\n\nWhat priors did rstanarm decide were good?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_summary(equality_model_prior)\n## Priors for model 'equality_model_prior' \n## ------\n## Intercept (after predictors centered)\n##  ~ normal(location = 2, scale = 0.5)\n## \n## Coefficients\n##   Specified prior:\n##     ~ normal(location = [0,0,0], scale = [2.5,2.5,2.5])\n##   Adjusted prior:\n##     ~ normal(location = [0,0,0], scale = [0.17,4.97,5.60])\n## ------\n## See help('prior_summary.stanreg') for more details\n```\n:::\n\n\nIt decided on $\\mathcal{N}(0, 0.17)$, $\\mathcal{N}(0, 4.97)$, and $\\mathcal{N}(0, 5.6)$, which is a lot wider than what I decided on above :shrug:.\n\nThose wider priors give a larger range of possible values than the narrow models earlier:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior_draws_rstanarm <- equality |> \n  group_by(historical) |> \n  summarize(min = min(percent_urban),\n            max = max(percent_urban)) |> \n  mutate(percent_urban = map2(min, max, ~seq(.x, .y, 1))) |> \n  unnest(percent_urban) |> \n  add_epred_draws(equality_model_prior, ndraws = 100)\n\nprior_draws_rstanarm |> \n  ggplot(aes(x = percent_urban, y = .epred)) +\n  geom_line(aes(group = paste(historical, .draw), color = historical), \n            alpha = 0.5, size = 0.5) +\n  coord_cartesian(ylim = c(0, 100)) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2])) +\n  labs(x = \"Percent urban\", y = \"Predicted number of laws\", color = \"Party\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n:::\n\n# 12.2: Simulating the posterior\n\nWith these informative-ish priors, we can finally fit the actual model and play with the posterior.\n\n## Run the model\n\nFOR FUN AND EXCITEMENT AND LEARNING I wrote the model in Stan here, but I'm not going to work with its posterior samples or anything for the rest of the notebook. I just wanted to try writing a non-OLS model in Stan. It is *definitely* not optimized or efficient or anything, but it works and it's neat.\n\n::: {.panel-tabset}\n### brms\n\n\n::: {.cell hash='12-chapter_cache/html/model-laws-brms_4f30e7faa6d4e9d90a835b53dd450310'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(2, 0.5), class = Intercept),\n            prior(student_t(2, 0, 1), class = b, coef = \"percent_urban\"),\n            prior(student_t(2, -0.5, 2), class = b, coef = \"historicalgop\"),\n            prior(student_t(2, 0, 2), class = b, coef = \"historicalswing\"))\n\nmodel_equality_brms <- brm(\n  bf(laws ~ percent_urban + historical),\n  data = equality,\n  family = poisson(),\n  prior = priors,\n  chains = 4, iter = 4000, seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0\n)\n## Start sampling\n```\n:::\n\n\n### rstanarm\n\n\n::: {.cell hash='12-chapter_cache/html/model-laws-rstanarm_55ac294c717af8a4665e219e9e460390'}\n\n```{.r .cell-code}\nequality_model <- stan_glm(\n  laws ~ percent_urban + historical, \n  data = equality, \n  family = poisson,\n  prior_intercept = normal(2, 0.5),\n  prior = normal(0, 2.5, autoscale = TRUE), \n  chains = 4, iter = 4000, seed = 84735, refresh = 0\n)\n```\n:::\n\n\n### Raw Stan\n\nThere are different ways to model GLMs in Stan. First we can use the more traditional mathy approach of calculating $\\lambda$ as a function of the intercept and all the slopes multiplied by all the Xs, then exponentiating the $\\lambda$, then feeding the unlogged $\\lambda$ to `poisson()` in Stan. This is precisely what the mathematical model says to do, but it involves manual matrix multiplication.\n\n\n::: {.cell file='12-stan/equality-manual.stan' output.var='' filename='12-stan/equality-manual.stan'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=0> n;  // Number of rows\n  int<lower=0> k;  // Number of predictors\n  matrix[n,k] X;   // Predictors\n  array[n] int Y;  // Outcome variable\n}\n\nparameters {\n  real alpha;\n  vector[k] beta;\n}\n\ntransformed parameters {\n  array[n] real log_lambda;\n  array[n] real<lower=0> lambda;\n  \n  for (i in 1:n) {\n    // We can be super explicit about the whole equation, expanding it to \n    // beta1*x1 + beta2*x2 + ..., or alternatively, we can use dot_product() to \n    // multiply all the betas and Xs at once\n    log_lambda[i] = alpha + beta[1] * X[i,1] + beta[2] * X[i,2] + beta[3] * X[i,3];\n    // log_lambda[i] = alpha + dot_product(X[i], beta);\n    \n    lambda[i] = exp(log_lambda[i]);\n  }\n}\n\nmodel {\n  alpha ~ normal(2, 0.5);\n  beta[1] ~ student_t(2, 0, 1);\n  beta[2] ~ student_t(2, -0.5, 2);\n  beta[3] ~ student_t(2, 0, 2);\n  \n  Y ~ poisson(lambda);\n}\n\ngenerated quantities {\n  array[n] int Y_rep;\n  vector[n] log_lik;\n  \n  for (i in 1:n) {\n    log_lik[i] = poisson_lpmf(Y[i] | lambda[i]);\n    Y_rep[i] = poisson_rng(lambda[i]);\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_stan_manual <- cmdstan_model(\"12-stan/equality-manual.stan\")\n```\n:::\n\n::: {.cell hash='12-chapter_cache/html/stan-equality-model-manual_7d24ca68dfe4f01d35569f6a14ebbf55'}\n\n```{.r .cell-code}\n# Build a matrix of predictors for Stan\nX <- model.matrix(~ 1 + percent_urban + historical, data = equality)[,-1]\n\nequality_samples_manual <- equality_stan_manual$sample(\n  data = list(n = nrow(equality), \n              Y = equality$laws, \n              X = X,\n              k = ncol(X)),\n  parallel_chains = 4, iter_warmup = 5000, iter_sampling = 5000, \n  refresh = 0, seed = BAYES_SEED\n)\n## Running MCMC with 4 parallel chains...\n## \n## Chain 1 finished in 1.4 seconds.\n## Chain 3 finished in 1.5 seconds.\n## Chain 2 finished in 1.9 seconds.\n## Chain 4 finished in 1.9 seconds.\n## \n## All 4 chains finished successfully.\n## Mean chain execution time: 1.7 seconds.\n## Total execution time: 2.0 seconds.\n```\n:::\n\n\nI'm not going to work with these Stan models in the rest of the notebook here because it's a hassle, but just to check that they worked, here are the coefficients, the LOO stats, and `pp_check()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_samples_manual$print(\n  variables = c(\"alpha\", \"beta[1]\", \"beta[2]\", \"beta[3]\"), \n  \"mean\", \"median\", \"sd\", ~quantile(.x, probs = c(0.025, 0.975))\n)\n##  variable  mean median   sd  2.5% 97.5%\n##   alpha    1.78   1.78 0.26  1.27  2.28\n##   beta[1]  0.02   0.02 0.00  0.01  0.02\n##   beta[2] -1.53  -1.52 0.13 -1.79 -1.27\n##   beta[3] -0.61  -0.61 0.10 -0.82 -0.42\n\nequality_samples_manual$loo()\n## \n## Computed from 20000 by 49 log-likelihood matrix\n## \n##          Estimate   SE\n## elpd_loo   -194.2 20.2\n## p_loo        17.7  4.6\n## looic       388.5 40.3\n## ------\n## Monte Carlo SE of elpd_loo is 0.1.\n## \n## Pareto k diagnostic values:\n##                          Count Pct.    Min. n_eff\n## (-Inf, 0.5]   (good)     47    95.9%   1013      \n##  (0.5, 0.7]   (ok)        2     4.1%   127       \n##    (0.7, 1]   (bad)       0     0.0%   <NA>      \n##    (1, Inf)   (very bad)  0     0.0%   <NA>      \n## \n## All Pareto k estimates are ok (k < 0.7).\n## See help('pareto-k-diagnostic') for details.\n\nequality_samples_manual |> \n  spread_draws(Y_rep[i]) |> \n  slice_sample(n = 25) |> \n  mutate(id = 1:n()) |> \n  ggplot(aes(x = Y_rep)) +\n  geom_density(aes(group = id), color = \"lightblue\", size = 0.25) +\n  geom_density(data = equality, aes(x = laws), color = \"darkblue\", size = 1)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n### Raw Stan (GLM shortcut)\n\nInstead of manually doing the matrix multiplication, Stan has shortcut functions specifically for running. [The `poisson_log_glm()` function](https://mc-stan.org/docs/functions-reference/poisson-log-glm.html), for instance, takes a matrix of predictors, the intercept, and the coefficients, and deals with all the math and multiplication automatically. \n\n\n::: {.cell file='12-stan/equality.stan' output.var='' filename='12-stan/equality.stan'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=0> n;  // Number of rows\n  int<lower=0> k;  // Number of predictors\n  matrix[n,k] X;   // Predictors\n  array[n] int Y;  // Outcome variable\n}\n\nparameters {\n  real alpha;\n  vector[k] beta;\n}\n\nmodel {\n  // Priors\n  alpha ~ normal(2, 0.5);\n  beta[1] ~ student_t(2, 0, 1);\n  beta[2] ~ student_t(2, -0.5, 2);\n  beta[3] ~ student_t(2, 0, 2);\n  \n  // Model\n  Y ~ poisson_log_glm(X, alpha, beta);\n}\n\ngenerated quantities {\n  array[n] int Y_rep;\n  vector[n] log_lik;\n\n  vector[n] lambda_hat = alpha + X * beta;\n  \n  for (i in 1:n) {\n    // We can use the shortcut poisson_log_glm_lpmf, which works just like \n    // poisson_log_glm from earlier\n    log_lik[i] = poisson_log_glm_lpmf({Y[i]} | X[i,], alpha, beta);\n\n    // Or we can use poisson_log_lpmf and feed it lambda_hat\n    // log_lik[i] = poisson_log_lpmf(Y[i] | lambda_hat[i]);\n\n    // Posterior predictive distribution\n    Y_rep[i] = poisson_log_rng(lambda_hat[i]);\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_stan <- cmdstan_model(\"12-stan/equality.stan\")\n```\n:::\n\n::: {.cell hash='12-chapter_cache/html/stan-equality-model_a5ae6b11888a5cf1c3ba65a12f9c9bab'}\n\n```{.r .cell-code}\nX <- model.matrix(~ 1 + percent_urban + historical, data = equality)[,-1]\n\nequality_samples <- equality_stan$sample(\n  data = list(n = nrow(equality), \n              Y = equality$laws, \n              X = X,\n              k = ncol(X)),\n  parallel_chains = 4, iter_warmup = 5000, iter_sampling = 5000, \n  refresh = 0, seed = BAYES_SEED\n)\n## Running MCMC with 4 parallel chains...\n## \n## Chain 1 finished in 0.7 seconds.\n## Chain 3 finished in 0.7 seconds.\n## Chain 2 finished in 0.9 seconds.\n## Chain 4 finished in 0.9 seconds.\n## \n## All 4 chains finished successfully.\n## Mean chain execution time: 0.8 seconds.\n## Total execution time: 1.0 seconds.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_samples$print(\n  variables = c(\"alpha\", \"beta[1]\", \"beta[2]\", \"beta[3]\"), \n  \"mean\", \"median\", \"sd\", ~quantile(.x, probs = c(0.025, 0.975))\n)\n##  variable  mean median   sd  2.5% 97.5%\n##   alpha    1.78   1.79 0.26  1.28  2.27\n##   beta[1]  0.02   0.02 0.00  0.01  0.02\n##   beta[2] -1.52  -1.52 0.13 -1.79 -1.27\n##   beta[3] -0.61  -0.61 0.10 -0.82 -0.41\nequality_samples$loo()\n## Warning: Some Pareto k diagnostic values are too high. See help('pareto-k-diagnostic') for details.\n## \n## Computed from 20000 by 49 log-likelihood matrix\n## \n##          Estimate   SE\n## elpd_loo   -194.5 20.3\n## p_loo        18.0  4.8\n## looic       389.0 40.7\n## ------\n## Monte Carlo SE of elpd_loo is NA.\n## \n## Pareto k diagnostic values:\n##                          Count Pct.    Min. n_eff\n## (-Inf, 0.5]   (good)     48    98.0%   963       \n##  (0.5, 0.7]   (ok)        0     0.0%   <NA>      \n##    (0.7, 1]   (bad)       1     2.0%   38        \n##    (1, Inf)   (very bad)  0     0.0%   <NA>      \n## See help('pareto-k-diagnostic') for details.\n\nequality_samples |> \n  spread_draws(Y_rep[i]) |> \n  slice_sample(n = 25) |> \n  mutate(id = 1:n()) |> \n  ggplot(aes(x = Y_rep)) +\n  geom_density(aes(group = id), color = \"lightblue\", size = 0.25) +\n  geom_density(data = equality, aes(x = laws), color = \"darkblue\", size = 1)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n:::\n\n\n## Regular diagnostics\n\nBefore looking at the coefficients/parameters and predictions, let's check the diagnostics:\n\n::: {.panel-tabset}\n## brms\n\n### Trace plots\n\nFUZZY.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_equality_brms |> \n  gather_draws(`^b_.*`, regex = TRUE) |> \n  ggplot(aes(x = .iteration, y = .value, color = factor(.chain))) +\n  geom_line(size = 0.1) +\n  scale_color_viridis_d(option = \"rocket\", end = 0.85) +\n  facet_wrap(vars(.variable), scales = \"free_y\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n### Trank plots\n\nNice and random\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_equality_brms |> \n  gather_draws(`^b_.*`, regex = TRUE) |> \n  group_by(.variable) |> \n  mutate(draw_rank = rank(.value)) |> \n  ggplot(aes(x = draw_rank, color = factor(.chain))) +\n  stat_bin(geom = \"step\", binwidth = 250, position = position_identity(), boundary = 0) +\n  scale_color_viridis_d(option = \"rocket\", end = 0.85) +\n  facet_wrap(vars(.variable), scales = \"free_y\") +\n  theme(axis.text.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n### Posterior predicive plots\n\nIt seems to be overpredicting values < 10, but it does follow the general shape of the data, so that's reassuring.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(model_equality_brms, ndraws = 50)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n### LOO, PSIS, and WAIC\n\nWe don't have too many issues with influential points with overly high Pareto k values, and `loo()` is generally happy:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloo(model_equality_brms)\n## \n## Computed from 8000 by 49 log-likelihood matrix\n## \n##          Estimate   SE\n## elpd_loo   -195.7 20.1\n## p_loo        19.7  5.1\n## looic       391.4 40.3\n## ------\n## Monte Carlo SE of elpd_loo is 0.2.\n## \n## Pareto k diagnostic values:\n##                          Count Pct.    Min. n_eff\n## (-Inf, 0.5]   (good)     46    93.9%   978       \n##  (0.5, 0.7]   (ok)        3     6.1%   126       \n##    (0.7, 1]   (bad)       0     0.0%   <NA>      \n##    (1, Inf)   (very bad)  0     0.0%   <NA>      \n## \n## All Pareto k estimates are ok (k < 0.7).\n## See help('pareto-k-diagnostic') for details.\n```\n:::\n\n\nFor fun, we can recreate Figure 7.10 from *Rethinking* to see which points are causing some outlier weirdness:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_equality_brms <- add_criterion(model_equality_brms, \n                                     criterion = c(\"loo\", \"waic\"))\n## Warning: \n## 13 (26.5%) p_waic estimates greater than 0.4. We recommend trying loo instead.\n\nbrms_diagnostics <- tibble(\n  psis = model_equality_brms$criteria$loo$diagnostics$pareto_k,\n  p_waic = model_equality_brms$criteria$waic$pointwise[, \"p_waic\"],\n  state = pull(equality, state)) |> \n  mutate(highlight = psis > 0.5 | p_waic > 1)\n\nbrms_diagnostics |> \n  ggplot(aes(x = psis, y = p_waic)) +\n  geom_point(aes(color = highlight)) +\n  geom_text_repel(data = filter(brms_diagnostics, highlight),\n                  aes(label = state), seed = 1234, direction = \"y\") +\n  geom_vline(xintercept = 0.5, linetype = 32) +\n  scale_color_manual(values = c(\"grey40\", clrs[4]), guide = \"none\") +\n  labs(x = \"PSIS Pareto k\", y = \"WAIC penalty\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## rstanarm\n\n### Trace plots\n\nStill fuzzy here too:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_model |> \n  gather_draws(`(Intercept)`, percent_urban, historicalgop, historicalswing) |> \n  ggplot(aes(x = .iteration, y = .value, color = factor(.chain))) +\n  geom_line(size = 0.1) +\n  scale_color_viridis_d(option = \"rocket\", end = 0.85) +\n  facet_wrap(vars(.variable), scales = \"free_y\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n### Trank plots\n\nGreat\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality_model |> \n  gather_draws(`(Intercept)`, percent_urban, historicalgop, historicalswing) |> \n  group_by(.variable) |> \n  mutate(draw_rank = rank(.value)) |> \n  ggplot(aes(x = draw_rank, color = factor(.chain))) +\n  stat_bin(geom = \"step\", binwidth = 250, position = position_identity(), boundary = 0) +\n  scale_color_viridis_d(option = \"rocket\", end = 0.85) +\n  facet_wrap(vars(.variable), scales = \"free_y\") +\n  theme(axis.text.y = element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n### Posterior predicive plots\n\nLovely\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(equality_model, n = 50)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n### LOO, PSIS, and WAIC\n\nInterestingly, rstanarm finds that 3 observations have bad Pareto k scores!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstanarm_loo <- loo(equality_model)\n## Warning: Found 3 observation(s) with a pareto_k > 0.7. We recommend calling 'loo' again with argument 'k_threshold = 0.7' in order to calculate the ELPD without the assumption that these observations are negligible. This will refit the model 3 times to compute the ELPDs for the problematic observations directly.\nrstanarm_loo\n## \n## Computed from 8000 by 49 log-likelihood matrix\n## \n##          Estimate   SE\n## elpd_loo   -196.1 20.2\n## p_loo        20.2  5.3\n## looic       392.2 40.3\n## ------\n## Monte Carlo SE of elpd_loo is NA.\n## \n## Pareto k diagnostic values:\n##                          Count Pct.    Min. n_eff\n## (-Inf, 0.5]   (good)     46    93.9%   851       \n##  (0.5, 0.7]   (ok)        0     0.0%   <NA>      \n##    (0.7, 1]   (bad)       3     6.1%   32        \n##    (1, Inf)   (very bad)  0     0.0%   <NA>      \n## See help('pareto-k-diagnostic') for details.\n```\n:::\n\n\nFor whatever reason, Maine and Vermont are super outliers now in the rstanarm model :shrug:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrstanarm_diagnostics <- tibble(\n  psis = rstanarm_loo$pointwise[, \"influence_pareto_k\"],\n  p_waic = waic(equality_model)$pointwise[, \"p_waic\"],\n  state = pull(equality, state)) |> \n  mutate(highlight = psis > 0.5 | p_waic > 1)\n## Warning: \n## 13 (26.5%) p_waic estimates greater than 0.4. We recommend trying loo instead.\n\nrstanarm_diagnostics |> \n  ggplot(aes(x = psis, y = p_waic)) +\n  geom_point(aes(color = highlight)) +\n  geom_text_repel(data = filter(rstanarm_diagnostics, highlight),\n                  aes(label = state), seed = 1234, direction = \"y\") +\n  geom_vline(xintercept = 0.5, linetype = 32) +\n  scale_color_manual(values = c(\"grey40\", clrs[4]), guide = \"none\") +\n  labs(x = \"PSIS Pareto k\", y = \"WAIC penalty\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## ELPD\n\nFor fun, we can compare the ELPD for the two models (more specific priors in brms; autoscaled priors in rstanarm) and see if one model performs better than the other. They're basically identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n  ~model, ~stats,\n  \"Default auto-scaled priors (rstanarm)\", as_tibble(rstanarm_loo$estimates, rownames = \"statistic\"),\n  \"Careful priors (brms)\", as_tibble(model_equality_brms$criteria$loo$estimates, rownames = \"statistic\")\n) |> \n  unnest(stats) |> \n  filter(statistic == \"elpd_loo\") |> \n  ggplot(aes(x = Estimate, y = model, color = model)) +\n  geom_pointrange(aes(xmin = Estimate - 2 * SE, xmax = Estimate + 2 * SE)) +\n  scale_y_discrete(labels = scales::label_wrap(15)) +\n  scale_color_manual(values = c(clrs[5], clrs[1]), guide = \"none\") +\n  labs(x = \"ELPD\", y = NULL)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n# 12.3: Interpreting the posterior\n\n## Coefficients / parameters\n\nSo what do these coefficients all actually mean? We can look at the fitted draws to see the predicted count of laws across a range of urban-ness and state political party\n\n::: {.panel-tabset}\n### brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality %>%\n  add_epred_draws(model_equality_brms, ndraws = 50) %>%\n  ggplot(aes(x = percent_urban, y = laws, color = historical)) +\n  geom_point(data = equality, size = 1) +\n  geom_line(aes(y = .epred, group = paste(historical, .draw)), \n            size = 0.5, alpha = 0.3) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2])) +\n  labs(x = \"Percent urban\", y = \"Count of laws\", color = \"Party\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n### rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality %>%\n  add_epred_draws(equality_model, ndraws = 50) %>%\n  ggplot(aes(x = percent_urban, y = laws, color = historical)) +\n  geom_point(data = equality, size = 1) +\n  geom_line(aes(y = .epred, group = paste(historical, .draw)), \n            size = 0.5, alpha = 0.3) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2])) +\n  labs(x = \"Percent urban\", y = \"Count of laws\", color = \"Party\") +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n:::\n\nLike we thought with our priors, Democratic states have more laws on average than GOP or swing states, and swing states have more than GOP states. The Democratic-GOP gap is substantial. Based just on the plot of predictions ↑ there, there's like a 15–20 law gap! Also, the count of laws is higher in urban states, also as expected.\n\nWe can look at the posterior distributions of the parameters/coefficients to get a more precise picture:\n\n::: {.panel-tabset}\n### brms\n\nLog-scale coefficients:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# There's a weird bug in broom.mixed or brms or somewhere that makes brms\n# Poisson models lose the term column here??? idk why??? tidy() works fine with\n# the rstanarm model, and parameters::parameters(model_equality_brms) shows the\n# terms fine. So here I just add them in manually with get_variables()\ncoefs_brms <- tidy(model_equality_brms) |> \n  select(-c(effect, component, group)) |> \n  mutate(term = get_variables(model_equality_brms)[1:4])\ncoefs_brms\n## # A tibble: 4 × 5\n##   term              estimate std.error conf.low conf.high\n##   <chr>                <dbl>     <dbl>    <dbl>     <dbl>\n## 1 b_Intercept         1.70     0.303    1.09       2.28  \n## 2 b_percent_urban     0.0164   0.00355  0.00967    0.0235\n## 3 b_historicalgop    -1.51     0.135   -1.78      -1.25  \n## 4 b_historicalswing  -0.609    0.104   -0.813     -0.405\n\nmodel_equality_brms |> \n  gather_draws(`^b_.*`, regex = TRUE) |>\n  mutate(.variable = factor(.variable, \n                            levels = c(\"b_Intercept\", \"b_percent_urban\", \n                                       \"b_historicalgop\", \"b_historicalswing\"),\n                            ordered = TRUE)) |> \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  scale_fill_manual(values = c(clrs[5], clrs[4], clrs[3], clrs[2]), guide = \"none\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\nUnlogged coefficients:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs_brms |> \n  mutate(across(c(estimate, conf.low, conf.high), ~exp(.)))\n## # A tibble: 4 × 5\n##   term              estimate std.error conf.low conf.high\n##   <chr>                <dbl>     <dbl>    <dbl>     <dbl>\n## 1 b_Intercept          5.49    0.303      2.96      9.78 \n## 2 b_percent_urban      1.02    0.00355    1.01      1.02 \n## 3 b_historicalgop      0.220   0.135      0.169     0.288\n## 4 b_historicalswing    0.544   0.104      0.444     0.667\n\nmodel_equality_brms |> \n  gather_draws(`^b_.*`, regex = TRUE) |>\n  mutate(.value = exp(.value)) |> \n  mutate(.variable = factor(.variable, \n                            levels = c(\"b_Intercept\", \"b_percent_urban\", \n                                       \"b_historicalgop\", \"b_historicalswing\"),\n                            ordered = TRUE)) |> \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  scale_fill_manual(values = c(clrs[5], clrs[4], clrs[3], clrs[2]), guide = \"none\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n### rstanarm\n\nLog-scale coefficients:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs_rstanarm <- tidy(equality_model, conf.int = TRUE)\ncoefs_rstanarm\n## # A tibble: 4 × 5\n##   term            estimate std.error conf.low conf.high\n##   <chr>              <dbl>     <dbl>    <dbl>     <dbl>\n## 1 (Intercept)       1.71     0.307     1.19      2.19  \n## 2 percent_urban     0.0165   0.00361   0.0108    0.0224\n## 3 historicalgop    -1.51     0.137    -1.74     -1.29  \n## 4 historicalswing  -0.608    0.103    -0.783    -0.439\n\nequality_model |> \n  gather_draws(`(Intercept)`, percent_urban, historicalgop, historicalswing) |>\n  mutate(.variable = factor(.variable, \n                            levels = c(\"(Intercept)\", \"percent_urban\", \n                                       \"historicalgop\", \"historicalswing\"),\n                            ordered = TRUE)) |> \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  scale_fill_manual(values = c(clrs[5], clrs[4], clrs[3], clrs[2]), guide = \"none\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\nUnlogged coefficients:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs_rstanarm |> \n  mutate(across(c(estimate, conf.low, conf.high), ~exp(.)))\n## # A tibble: 4 × 5\n##   term            estimate std.error conf.low conf.high\n##   <chr>              <dbl>     <dbl>    <dbl>     <dbl>\n## 1 (Intercept)        5.50    0.307      3.28      8.95 \n## 2 percent_urban      1.02    0.00361    1.01      1.02 \n## 3 historicalgop      0.220   0.137      0.175     0.274\n## 4 historicalswing    0.544   0.103      0.457     0.645\n\nequality_model |> \n  gather_draws(`(Intercept)`, percent_urban, historicalgop, historicalswing) |>\n  mutate(.value = exp(.value)) |> \n  mutate(.variable = factor(.variable, \n                            levels = c(\"(Intercept)\", \"percent_urban\", \n                                       \"historicalgop\", \"historicalswing\"),\n                            ordered = TRUE)) |> \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  scale_fill_manual(values = c(clrs[5], clrs[4], clrs[3], clrs[2]), guide = \"none\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n:::\n\n### Interpretation\n\nInterpretation time!\n\n- **The intercept ($\\beta_0$)**: On the logged scale, this is the intercept when percent urban is 0 in historically Democratic states. On its own it's meaningless; exponentiating it gives us an expected count of laws in a completely rural Democratic state. The mean unlogged posterior value here is 5.5 laws, with a 95% credible interval ranging from 3 to 9.8.\n\n- **The percent urban coefficient ($\\beta_1$)**: This is the slope of the line on the logged scale. We should expect the logged number of laws in a state to increase by that amount for each additional percentage point of urban-ness. The mean posterior value is 0.0164, with a 95% credible interval ranging from 0.0097 to 0.0235. That seems really tiny. We can make it more interpretable by exponentiating it, where a 1 percentage point increase in urban-ness is associated with an average of 1.0166 times (or 1.66%) more laws, with a 95% credible interval ranging from 1.0097 to 1.0238 (0.97% to 2.38%).\n\n    We can make this a little more interpretable if we think in larger changes. In *Bayes Rules!* they say to imagine that the urban population in one state is 25 percentage points higher than another state. If that's the case, we would expect $e^{25 \\times 0.0164} \\approx 1.51$ or 51% more laws, or 1.5 times the number of laws. If that rural state had 10 laws, we'd expect 15 laws in the more urban state.\n\n- **The historically GOP coefficient ($\\beta_2$)**: This is the shift in the logged intercept for historically Republican states. The logged number of laws is lower by 1.5 on average, but that doesn't make sense on its own. After exponentiation, we can think about ratios of GOP laws to Democratic laws. Here, that ratio has a posterior mean of 0.22 with a 95% credible interval of 0.169 to 0.288, meaning that Republican states have 22% (or 16.9%–28.8%) of the count of laws in similar Democratic states. That's a sizable difference! Compared to a Democratic state with 20 laws, a Republican state is predicted to only have 3–5 laws (20 × 0.169, 20 × 0.288). Oof.\n\n- **The historically swing state coefficient ($\\beta_3$)**: This is the shift in the logged intercept for historically swing states. We interpret it the same way as the GOP shift. On the log scale it makes little sense; exponentiated, it has a posterior mean of 0.544 with a 95% credible interval of 0.444 to 0.667. That means that swing states have between 44.4%–66.67% of the laws of a Democratic state. Compared to a Democratic state with 20 laws, a swing state is predicted to have 9–13 laws (20 × 0.444, 20 × 0.667).\n\n\n## Marginal effects\n\nUnlogging these coefficients makes interpretation a lot easier, but it would be nice to work with counts directly too. We already did that in each of those interpretation paragraphs, translating the percent-level effects to counts in hypothetical situations (rural state with 10 laws, Democratic state with 20 laws, etc.). We can be more systematic about these conversions to counts by calculating marginal effects.\n\nBecause this model is curvy, the slope of the fitted line changes depending on the value of percent urban. Additionally, the size of the party-specific intercept shift changes across different values of the count of laws. So instead, we can look at the overall average slope and change in intercept across the whole range of values. And because we're working with posterior distributions, we actually get posterior distributions of marginal effects too!\n\nIf we look at overall marginal effect, we find that the posterior mean of the partial derivative for `percent_urban` *on the count (or response) scale* is 0.173, with a 95% credible interval of 0.1 to 0.25. That means that on an average, increasing urban-ness by one percentage point is associated with 0.1–0.25 additional laws, on average. The group contrasts are also helpful (and already on the count scale!). The average overall difference between Republican and Democratic states has a posterior mean of -14.64 laws, with a 95% credible interval of 12–17 laws, while the difference between swing states and Democratic states has a posterior mean of -8.5 laws (5.73–11.5). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_brms <- marginaleffects(model_equality_brms, type = \"response\")\ntidy(mfx_brms)\n##       type          term    contrast   estimate  conf.low   conf.high\n## 1 response percent_urban       dY/dX   0.173300   0.10019   0.2504355\n## 2 response    historical   gop - dem -14.635854 -17.31778 -12.0961604\n## 3 response    historical swing - dem  -8.561223 -11.50006  -5.7257059\n```\n:::\n\n\nThat's the marginal effect for the average of the whole range of urban-ness, but it's maybe even more useful to look at the marginal effect at each possible level of percent urban.\n\nThis ends up being really neat! For the percent urban effect, it is small in rural states across all parties—down at 50% urban, a 1 percentage point increase in urban-ness is associated with 0.2 additional laws for Democratic states, 0.1ish for swing states, and nearly 0 for Republican states.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_brms_typical <- model_equality_brms |> \n  marginaleffects(newdata = datagrid(percent_urban = seq(40, 90, by = 5),\n                                     historical = c(\"dem\", \"gop\", \"swing\")),\n                  variables = c(\"percent_urban\", \"historical\")) |> \n  posteriordraws()\n\nmfx_brms_typical |> \n  filter(term != \"historical\" | !(historical %in% c(\"gop\", \"swing\"))) |> \n  mutate(historical = ifelse(term == \"historical\", \"contrast\", as.character(historical))) |> \n  mutate(term = fct_inorder(term)) |> \n  ggplot(aes(x = percent_urban, y = draw, color = historical, fill = historical)) +\n  stat_lineribbon(alpha = 0.25) +\n  scale_color_manual(values = c(clrs[6], clrs[3], clrs[2], clrs[1]),\n                     breaks = c(\"dem\", \"gop\", \"swing\"), na.value = clrs[1]) +\n  scale_fill_manual(values = c(clrs[6], clrs[3], clrs[2], clrs[1]),\n                    breaks = c(\"dem\", \"gop\", \"swing\"), na.value = clrs[1]) +\n  facet_nested_wrap(vars(term, contrast), scales = \"free_y\") +\n  labs(color = NULL, fill = NULL, x = \"Percent urban\",\n       y = \"Marginal effect or ∆ in group means\\nCount of laws\") +\n  theme(legend.position = \"bottom\")\n## Warning: Using the `size` aesthietic with geom_ribbon was deprecated in ggplot2 3.4.0.\n## ℹ Please use the `linewidth` aesthetic instead.\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Warning: Using the `size` aesthietic with geom_line was deprecated in ggplot2 3.4.0.\n## ℹ Please use the `linewidth` aesthetic instead.\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-48-1.png){width=864}\n:::\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n### More automatic marginal effects plots\n\n↑ that's all fancy with nested facets and manual ggplot work; we can also make these same plots with the `plot_cme()` function in **marginaleffects**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_cme(model_equality_brms, \n         effect = \"percent_urban\",\n         condition = c(\"percent_urban\", \"historical\"))\n\nplot_cme(model_equality_brms, \n         effect = \"historical\",\n         condition = \"percent_urban\")\n```\n:::\n\n\n:::\n\n\n# 12.4: Posterior prediction\n\nWe can check how well this model predicts data by comparing the actual data of some state to the posterior predictive distribution for that state. In the book they use Minnesota, historically Democratic, fairly urban, with just 4 laws:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequality |> filter(state == \"minnesota\")\n## # A tibble: 1 × 6\n##   state     region  gop_2016  laws historical percent_urban\n##   <fct>     <fct>      <dbl> <dbl> <fct>              <dbl>\n## 1 minnesota midwest     44.9     4 dem                 73.3\n```\n:::\n\n\nWhat does the model predict? We can use `posterior_predict()` to find that out. It will return actual integer counts (since posterior predictions are [on the original scale of the data](https://www.andrewheiss.com/blog/2022/09/26/guide-visualizing-types-posteriors/)):\n\n::: {.panel-tabset}\n## brms\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmn_pred_brms <- model_equality_brms |> \n  predicted_draws(newdata = filter(equality, state == \"minnesota\"))\n\nmn_pred_brms |> \n  ggplot(aes(x = .prediction)) +\n  stat_histinterval(slab_fill = clrs[4], slab_color = \"white\", outline_bars = TRUE,\n                    slab_size = 0.5) +\n  geom_vline(xintercept = 4)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n\n## brms without `posterior_predict()`\n\nJust for fun, the book creates the posterior predictive distribution by hand by making the linear predictor $\\lambda$ for Minnesota, then using `rpois()` to simulate the number of laws based on that $\\lambda$. It's the same!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_equality_brms |> \n  spread_draws(`^b_.*`, regex = TRUE) |> \n  mutate(log_lambda = b_Intercept + b_percent_urban*73.3 + \n           b_historicalgop*0 + b_historicalswing*0,\n         lambda = exp(log_lambda),\n         y_new = rpois(n(), lambda = lambda)) |> \n  ggplot(aes(x = y_new)) +\n  stat_histinterval(slab_fill = clrs[4], slab_color = \"white\", outline_bars = TRUE,\n                    slab_size = 0.5) +\n  geom_vline(xintercept = 4)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\n## rstanarm\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmn_pred_rstanarm <- equality_model |> \n  predicted_draws(newdata = filter(equality, state == \"minnesota\"))\n\nmn_pred_rstanarm |> \n  ggplot(aes(x = .prediction)) +\n  stat_histinterval(slab_fill = clrs[4], slab_color = \"white\", outline_bars = TRUE,\n                    slab_size = 0.5) +\n  geom_vline(xintercept = 4)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n:::\n\n\n# 12.5: Model evaluation\n\n## 1. How fair is the model?\n\nIt's good.\n\n## 2. How wrong is the model?\n\n`pp_check()` earlier showed that it overpredict values < 10, but it does follow the general shape of the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(model_equality_brms, ndraws = 50)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\n## 3. How accurate are the model's predictions?\n\nWe checked that with LOO, ELPD, and PSIS stuff earlier. It's all pretty good.\n\n\n# 12.6: Negative binomial regression for overdispersed counts\n\nThis Poisson stuff is neat as long as the assumptions hold, in particular the requirement that the mean and variance of $Y$ are the same. If that's not the case, things break.\n\nFor instance, we can model the number of books people read per year based on whether they would like to be wise but unhappy, or happy but unwise. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(pulse_of_the_nation, package = \"bayesrules\")\n\npulse <- pulse_of_the_nation |> \n  filter(books < 100)\n```\n:::\n\n\nThe number of books people read looks Poisson-y, but with a lot more super low values than we might expect from a regular Poisson distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\npulse |> \n  ggplot(aes(x = books)) +\n  geom_histogram(binwidth = 5, boundary = 0, color = \"white\", size = 0.25)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\nThe mean and variance aren't the same: \n\n\n::: {.cell}\n\n```{.r .cell-code}\npulse |> \n  summarise(mean = mean(books),\n            variance = sd(books))\n## # A tibble: 1 × 2\n##    mean variance\n##   <dbl>    <dbl>\n## 1  10.9     14.1\n```\n:::\n\n\nAnd they're not the same across a range of ages and wise/unwise responses:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npulse |> \n  mutate(age_bins = santoku::chop_quantiles(age, \n                                            c(0.25, 0.5, 0.75))) |> \n  group_by(age_bins, wise_unwise) |> \n  summarise(mean = mean(books),\n            variance = sd(books))\n## # A tibble: 8 × 4\n## # Groups:   age_bins [4]\n##   age_bins    wise_unwise       mean variance\n##   <fct>       <fct>            <dbl>    <dbl>\n## 1 [0%, 25%)   Happy but Unwise  9.10     12.0\n## 2 [0%, 25%)   Wise but Unhappy 14.8      15.2\n## 3 [25%, 50%)  Happy but Unwise  8.34     10.3\n## 4 [25%, 50%)  Wise but Unhappy 11.4      15.3\n## 5 [50%, 75%]  Happy but Unwise  9.09     13.5\n## 6 [50%, 75%]  Wise but Unhappy 12.3      15.1\n## 7 (75%, 100%] Happy but Unwise 11.7      15.5\n## 8 (75%, 100%] Wise but Unhappy 10.9      14.4\n```\n:::\n\n\nThis means that $Y$ here is **overdispersed**, or that it has too much variability.\n\nWe can throw it at a Poisson model and it'll fit just fine:\n\n\n::: {.cell hash='12-chapter_cache/html/model-pulse-poisson_acfcb24032848369b29a047dde07f96a'}\n\n```{.r .cell-code}\nmodel_pulse_poisson <- brm(\n  bf(books ~ age + wise_unwise),\n  data = pulse,\n  family = poisson(),\n  chains = 4, iter = 4000, seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0\n)\n## Start sampling\n```\n:::\n\n\nBut if we look at a posterior predictive check, we have serious problems\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# oh no\npp_check(model_pulse_poisson)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\nWith negative binomial models, we get to estimate two parameters: $\\mu$, which is like Poisson's $\\lambda$, and $r$, which is a non-negative \"reciprocal dispersion\" thing:\n\n$$\n\\begin{aligned}\nY_u &\\sim \\operatorname{NegBin}(\\mu_i, r) \\\\\n\\log(\\mu_i) &= \\beta_0 + \\beta_1 X_{i1} + \\beta_2 X_{i2} + \\dots \\\\\n\\\\\n\\beta_0, \\beta_1, \\beta_2, \\beta_{\\dots} &\\sim \\text{Some prior} \\\\\nr &\\sim \\text{Some prior} > 0\n\\end{aligned}\n$$\n\n\n::: {.cell hash='12-chapter_cache/html/model-pulse-negbinom_0d52c9f0c92f5a635a070911217b9cf0'}\n\n```{.r .cell-code}\nmodel_pulse_negbinom <- brm(\n  bf(books ~ age + wise_unwise),\n  data = pulse,\n  family = negbinomial(),\n  chains = 4, iter = 4000, seed = BAYES_SEED, \n  backend = \"cmdstanr\", refresh = 0\n)\n## Start sampling\n```\n:::\n\n\nThis fits almost perfectly now!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# oh no\npp_check(model_pulse_negbinom)\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\nThe coefficients are interpreted just like Poisson ones, since negative binomial uses a log link. Here are the different scales everything:\n\n- `posterior_predict()`, or $Y$: Integers of counts of outcome\n- `posterior_linpred()`, or $\\log{\\mu}$: Logged predicted outcome\n- `posterior_epred()` or `posterior_linpred(transform = TRUE)`, or $\\mu$: Unlogged (exponentiated) predicted outcome\n\nHere are the coefficients, both logged and unlogged:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoefs_negbinom <- tidy(model_pulse_negbinom) |> \n  select(-c(effect, component, group)) |> \n  mutate(term = get_variables(model_pulse_negbinom)[1:3])\n\ncoefs_negbinom |> \n  mutate(term = fct_inorder(term),\n         scale = \"Logged\", .before = 1) |> \n  bind_rows(\n    coefs_negbinom |> \n      mutate(across(c(estimate, conf.low, conf.high), ~exp(.)),\n             scale = \"Unlogged\")\n  ) |> \n  arrange(term)\n## # A tibble: 6 × 6\n##   scale    term                        estimate std.error conf.low conf.high\n##   <chr>    <chr>                          <dbl>     <dbl>    <dbl>     <dbl>\n## 1 Logged   b_age                       0.000326   0.00240 -0.00443   0.00500\n## 2 Unlogged b_age                       1.00       0.00240  0.996     1.01   \n## 3 Logged   b_Intercept                 2.24       0.134    1.98      2.50   \n## 4 Unlogged b_Intercept                 9.36       0.134    7.24     12.2    \n## 5 Logged   b_wise_unwiseWisebutUnhappy 0.266      0.0800   0.113     0.424  \n## 6 Unlogged b_wise_unwiseWisebutUnhappy 1.30       0.0800   1.12      1.53\n```\n:::\n\n\nWe'll just plot the unlogged ones because thinking about logs is weird.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_pulse_negbinom |> \n  gather_draws(`^b_.*`, regex = TRUE) |>\n  mutate(.value = exp(.value)) |> \n  mutate(.variable = factor(.variable, \n                            levels = c(\"b_Intercept\", \"b_age\", \n                                       \"b_wise_unwiseWisebutUnhappy\"),\n                            ordered = TRUE)) |> \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye(normalize = \"xy\") +\n  scale_fill_manual(values = c(clrs[1], clrs[2], clrs[3]), guide = \"none\") +\n  facet_wrap(vars(.variable), scales = \"free_x\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\nGeneral interpretation, just to get used to working with these coefficients:\n\n- The unlogged intercept shows the expected count of books read when age is 0 and people want to be unwise but happy. The mean posterior value here is 9.3, with a 95% credible interval of 7.2–12.2.\n- The unlogged coefficient for age shows the multiplicative change in the number of books read. A one-year increase in age is associated with a posterior average 0.03% increase in books read (or 1.0003 times), with a 95% credible interval of 0.9956–1.005. That's hardly anything. There's mostly likely not any sort of relationship here.\n- The unlogged coefficient for wise but unhappy shows the percent or ratio of books read compared to the happy but unwise comparison group. The posterior mean is 1.3 with a 95% credible interval of 1.12–1.53, meaning that people who want to be wise but unhappy read 1.3 times (or 130%) as many books as their unwise happy counterparts. If a happy unwise person reads 10 books a year, a comparable unhappy wise person would be expected to read 13 books (or rather, somewhere between 11.2 and 15.3 books).\n\nHere's what all these moving parts look like simultaneously:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npulse %>%\n  add_epred_draws(model_pulse_negbinom, ndraws = 50) %>%\n  ggplot(aes(x = age, y = books, color = wise_unwise)) +\n  geom_point(data = pulse, size = 0.5, alpha = 0.8) +\n  geom_line(aes(y = .epred, group = paste(wise_unwise, .draw)), \n            size = 0.5, alpha = 0.3) +\n  scale_color_manual(values = c(clrs[4], clrs[3])) +\n  labs(x = \"Age\", y = \"Count of books\", color = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-63-1.png){width=672}\n:::\n:::\n\n\nThe slope is flat, so age doesn't matter, but there is a recognizable gap in the happy/wise question—those who want to be wise read more books.\n\nFor fun, we can also look at the marginal effect of the happy/wise variable so we don't have to work with percentages like 130%.\n\nOn average, the marginal effect of wanting to be wise over wanting to be happy is associated with almost 3 more books read per year (1.2–4.7 in the 95% credible interval):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_neg_binom <- marginaleffects(model_pulse_negbinom, type = \"response\")\ntidy(mfx_neg_binom)\n##       type        term                            contrast    estimate\n## 1 response         age                               dY/dX 0.003665476\n## 2 response wise_unwise Wise but Unhappy - Happy but Unwise 2.884521215\n##      conf.low  conf.high\n## 1 -0.04831247 0.05471462\n## 2  1.21990466 4.68279566\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_neg_binom |> \n  posteriordraws() |> \n  filter(contrast != \"dY/dX\") |> \n  ggplot(aes(x = draw)) +\n  stat_halfeye(fill = clrs[3])\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-65-1.png){width=672}\n:::\n:::\n\n\nWe can also look at the gap across the full range of ages, though it's not that exciting or interesting since the age slope is completeley flat. The 3-book boost happens at every possible age.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmfx_pulse_ages <- model_pulse_negbinom |> \n  marginaleffects(newdata = datagrid(age = seq(18, 99, by = 1),\n                                     wise_unwise = c(\"Wise but Unhappy\")),\n                  variables = c(\"wise_unwise\")) |> \n  posteriordraws()\n\nmfx_pulse_ages |> \n  ggplot(aes(x = age, y = draw, color = wise_unwise, fill = wise_unwise)) +\n  stat_lineribbon(alpha = 0.25) +\n  scale_color_manual(values = c(clrs[4], clrs[3])) +\n  scale_fill_manual(values = c(clrs[4], clrs[3])) +\n  labs(color = NULL, fill = NULL, x = \"Age\",\n       y = \"∆ in group means\") +\n  theme(legend.position = \"bottom\")\n## Warning: Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n## Unknown or uninitialised column: `linewidth`.\n```\n\n::: {.cell-output-display}\n![](12-chapter_files/figure-html/unnamed-chunk-66-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}