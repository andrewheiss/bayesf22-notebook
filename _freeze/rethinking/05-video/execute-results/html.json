{
  "hash": "1c2e8a47ba7b94e3e19786ff596b1718",
  "result": {
    "markdown": "---\ntitle: \"Video #5 code\"\nsubtitle: \"Elemental confounds\"\ndate: \"September 21, 2022\"\nformat:\n  html:\n    toc-depth: 5\neditor_options: \n  chunk_output_type: inline\n---\n\n\n<div class=\"ratio ratio-16x9\">\n<iframe src=\"https://www.youtube.com/embed/UpP-_mBvECI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n\n\n\n\n$$\n\\newcommand{\\ind}{\\perp\\!\\!\\!\\perp}\n\\newcommand{\\notind}{\\not\\!\\perp\\!\\!\\!\\perp}\n$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(brms)\nlibrary(tidybayes)\nlibrary(ggdag)\nlibrary(ggrepel)\nlibrary(patchwork)\n\n# Plot stuff\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Seed stuff\nBAYES_SEED <- 1234\nset.seed(1234)\n```\n:::\n\n\n## The fork (confounders)\n\n$$\nX \\leftarrow Z \\rightarrow Y\n$$\n\n$Z$ connects $X$ and $Y$ so that $Y \\notind X$\n\n### Simulated example\n\nWe can make some data to prove that they're connected:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1000\n\nfork_sim <- tibble(Z = rbinom(n, 1, prob = 0.5)) %>% \n  # When Z is 0, there's a 10% chance of X or Y being 1\n  # When Z is 1, there's a 90% chance of X or Y being 1\n  mutate(X = rbinom(n, 1, prob = ((1 - Z) * 0.1) + (Z * 0.9)),\n         Y = rbinom(n, 1, prob = ((1 - Z) * 0.1) + (Z * 0.9)))\n\nfork_sim %>% \n  select(-Z) %>% \n  table()\n##    Y\n## X     0   1\n##   0 390 101\n##   1  82 427\n\nfork_sim %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 1 × 1\n##     cor\n##   <dbl>\n## 1 0.634\n```\n:::\n\n\nBut if we stratify by (or adjust for) $Z$, we can see that $Y \\ind X \\mid Z$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfork_sim %>% \n  select(X, Y, Z) %>% \n  table()\n## , , Z = 0\n## \n##    Y\n## X     0   1\n##   0 388  56\n##   1  36   2\n## \n## , , Z = 1\n## \n##    Y\n## X     0   1\n##   0   2  45\n##   1  46 425\n\nfork_sim %>% \n  group_by(Z) %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 2 × 2\n##       Z     cor\n##   <int>   <dbl>\n## 1     0 -0.0609\n## 2     1 -0.0546\n```\n:::\n\n\nHere's a continuous version too. When looking at all values of $Z$, there's a positive slope and relationship; when looking within each group, the relationship is 0 and flat.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 300\n\nfork_sim_cont <- tibble(Z = rbinom(n, 1, 0.5)) %>% \n  mutate(X = rnorm(n, 2 * Z - 1),\n         Y = rnorm(n, 2 * Z - 1))\n\nggplot(fork_sim_cont, aes(x = X, y = Y, color = factor(Z))) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  geom_smooth(aes(color = NULL), method = \"lm\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/fork-sim-continuous-1.png){width=672}\n:::\n:::\n\n\n### Waffle House example\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(WaffleDivorce, package = \"rethinking\")\n\nWaffleDivorce <- WaffleDivorce %>% \n  mutate(across(c(Marriage, Divorce, MedianAgeMarriage), ~scale(.), .names = \"{col}_scaled\")) %>% \n  mutate(across(c(Marriage, Divorce, MedianAgeMarriage), ~as.numeric(scale(.)), .names = \"{col}_z\"))\n```\n:::\n\n\nWhat is the causal effect of marriage on divorce?\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheight_sex_dag <- dagify(\n  x ~ z,\n  y ~ x + z,\n  exposure = \"x\",\n  outcome = \"y\",\n  labels = c(x = \"Marriage\", y = \"Divorce\", z = \"Age\"),\n  coords = list(x = c(x = 1, y = 3, z = 2),\n                y = c(x = 1, y = 1, z = 2))) %>% \n  tidy_dagitty() %>% \n  node_status()\n\nggplot(height_sex_dag, aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point(aes(color = status)) +\n  geom_dag_text(aes(label = label), size = 3.5, color = \"black\") +\n  scale_color_manual(values = clrs[c(1, 4)], guide = \"none\") +\n  theme_dag()\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/full-dag-1.png){fig-align='center' width=480}\n:::\n:::\n\n\nWe can look at the relationship of all three of these arrows\n\n::: {.panel-tabset}\n#### Age → Marriage\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(WaffleDivorce, aes(x = MedianAgeMarriage, y = Marriage)) +\n  geom_point(aes(fill = factor(South)), size = 4, pch = 21, color = \"white\") +\n  geom_smooth(method = \"lm\") +\n  geom_text_repel(aes(label = Loc), max.overlaps = 2) +\n  scale_fill_manual(values = clrs[c(1, 3)], guide = \"none\") +\n  labs(x = \"Median age of marriage\", y = \"Marriage rate\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-age-marriage-1.png){width=672}\n:::\n:::\n\n\n#### Age → Divorce\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(WaffleDivorce, aes(x = MedianAgeMarriage, y = Divorce)) +\n  geom_point(aes(fill = factor(South)), size = 4, pch = 21, color = \"white\") +\n  geom_smooth(method = \"lm\") +\n  geom_text_repel(aes(label = Loc), max.overlaps = 2) +\n  scale_fill_manual(values = clrs[c(1, 3)], guide = \"none\") +\n  labs(x = \"Median age of marriage\", y = \"Divorce rate\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-age-divorce-1.png){width=672}\n:::\n:::\n\n\n#### Marriage → Divorce\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(WaffleDivorce, aes(x = Marriage, y = Divorce)) +\n  geom_point(aes(fill = factor(South)), size = 4, pch = 21, color = \"white\") +\n  geom_smooth(method = \"lm\") +\n  geom_text_repel(aes(label = Loc), max.overlaps = 2) +\n  scale_fill_manual(values = clrs[c(1, 3)], guide = \"none\") +\n  labs(x = \"Marriage rate\", y = \"Divorce rate\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-marriage-divorce-1.png){width=672}\n:::\n:::\n\n\n:::\n\nHow do we stratify by a continuous variable though? Regression!\n\n$$\n\\begin{aligned}\nD_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\alpha + \\beta_M M_i + \\beta_A A_i\n\\end{aligned}\n$$\n\n#### Prior predictive simulation\n\n$$\n\\begin{aligned}\nD_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\alpha + \\beta_M M_i + \\beta_A A_i \\\\\n\\\\\n\\alpha &\\sim \\mathcal{N}(0, 0.2) \\\\\n\\beta_M &\\sim \\mathcal{N}(0, 0.5) \\\\\n\\beta_A &\\sim \\mathcal{N}(0, 0.5) \\\\\n\\sigma &\\sim \\operatorname{Exponential}(1)\n\\end{aligned}\n$$\n\n\n::: {.cell hash='05-video_cache/html/age-marriage-prior-only_fa1bf2d146d366645fd5c2ceb8e2ac8f'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(0, 0.2), class = Intercept),\n            prior(normal(0, 0.5), class = b, coef = \"Marriage_z\"),\n            prior(normal(0, 0.5), class = b, coef = \"MedianAgeMarriage_z\"),\n            prior(exponential(1), class = sigma))\n\nmarriage_divorce_prior_only <- brm(\n  bf(Divorce_z ~ Marriage_z + MedianAgeMarriage_z),\n  data = WaffleDivorce,\n  family = gaussian(),\n  prior = priors,\n  sample_prior = \"only\",\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndraws_prior <- tibble(MedianAgeMarriage_z = seq(-2, 2, length.out = 100),\n                      Marriage_z = 0) %>% \n  add_epred_draws(marriage_divorce_prior_only, ndraws = 100)\n\ndraws_prior %>% \n  ggplot(aes(x = MedianAgeMarriage_z, y = .epred)) +\n  geom_line(aes(group = .draw), alpha = 0.2) +\n  labs(x = \"Median age of marriage (standardized)\",\n       y = \"Divorce rate (standardized)\",\n       caption = \"Standardized marriage rate held constant at 0\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-age-marriage-prior-1.png){width=672}\n:::\n:::\n\n\n#### Actual model\n\nBased on these models, \n\n> Once we know median age at marriage for a state, there is little or no additional predictive power in also knowing the rate of marriage in that state. (p. 134)\n\n::: {.panel-tabset}\n##### brms\n\n\n::: {.cell hash='05-video_cache/html/age-marriage-actual_a55b56253ab7a7862be2cf3debbdf2d9'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(0, 0.2), class = Intercept),\n            prior(normal(0, 0.5), class = b, coef = \"Marriage_z\"),\n            prior(normal(0, 0.5), class = b, coef = \"MedianAgeMarriage_z\"),\n            prior(exponential(1), class = sigma))\n\nmarriage_divorce_actual <- brm(\n  bf(Divorce_z ~ Marriage_z + MedianAgeMarriage_z),\n  data = WaffleDivorce,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## recompiling to avoid crashing R session\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(marriage_divorce_actual)\n##  Family: gaussian \n##   Links: mu = identity; sigma = identity \n## Formula: Divorce_z ~ Marriage_z + MedianAgeMarriage_z \n##    Data: WaffleDivorce (Number of observations: 50) \n##   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n##          total post-warmup draws = 4000\n## \n## Population-Level Effects: \n##                     Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## Intercept              -0.00      0.10    -0.20     0.20 1.00     3824     2317\n## Marriage_z             -0.07      0.15    -0.36     0.24 1.00     3087     2922\n## MedianAgeMarriage_z    -0.62      0.16    -0.92    -0.31 1.00     2894     2655\n## \n## Family Specific Parameters: \n##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sigma     0.83      0.09     0.68     1.01 1.00     3630     2543\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# get_variables(marriage_divorce_actual)\n\nmarriage_divorce_actual %>% \n  gather_draws(b_Intercept, b_Marriage_z, b_MedianAgeMarriage_z, sigma) %>% \n  ggplot(aes(x = .value, y = fct_rev(.variable))) +\n  stat_halfeye() +\n  coord_cartesian(xlim = c(-1, 1))\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-age-marriage-actual-coefs-1.png){width=672}\n:::\n:::\n\n\n##### Stan\n\n**marriage_divorce_stan.stan**\n\n\n::: {.cell output.var='marriage_divorce_stan' hash='05-video_cache/html/marriage-divorce-stan_e4cf341144991e91675df4852801fdf2'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=1> n;  // Observations\n  vector[n] Divorce_z;  // Outcome: divorce rate\n  vector[n] Marriage_z;  // \"Treatment\": marriage rate\n  vector[n] MedianAgeMarriage_z;  // Confounder: age\n}\n\nparameters {\n  real a;\n  real bM;\n  real bA;\n  real<lower=0> sigma;\n}\n\ntransformed parameters {\n  vector[n] mu;\n  mu = a + bM*Marriage_z + bA*MedianAgeMarriage_z;\n}\n\nmodel {\n  // Likelihood\n  Divorce_z ~ normal(mu, sigma);\n  \n  // Priors\n  a ~ normal(0, 0.2);\n  bM ~ normal(0, 0.5);\n  bA ~ normal(0, 0.5);\n  sigma ~ exponential(1);\n}\n\ngenerated quantities {\n  vector[n] Divorce_z_rep;\n  \n  for (i in 1:n) {\n    Divorce_z_rep[i] = normal_rng(mu[i], sigma);\n  }\n}\n```\n:::\n\n::: {.cell hash='05-video_cache/html/marriage-divorce-stan-samples_5bd94271a1f071d2e8d0ada9f7ade461'}\n\n```{.r .cell-code}\nstan_data <- WaffleDivorce %>% \n  select(Divorce_z, Marriage_z, MedianAgeMarriage_z) %>% \n  compose_data()\n\nmodel_marriage_divorce_stan <- rstan::sampling(\n  object = marriage_divorce_stan,\n  data = stan_data,\n  iter = 2000, warmup = 1000, seed = BAYES_SEED, chains = 4, cores = 4\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_marriage_divorce_stan,\n      pars = c(\"a\", \"bM\", \"bA\", \"sigma\"))\n## Inference for Stan model: 8cc6e06905b678b9147ee76469c82d06.\n## 4 chains, each with iter=2000; warmup=1000; thin=1; \n## post-warmup draws per chain=1000, total post-warmup draws=4000.\n## \n##        mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\n## a      0.00       0 0.10 -0.19 -0.07  0.00  0.07  0.20  3754    1\n## bM    -0.06       0 0.15 -0.36 -0.17 -0.06  0.04  0.24  2518    1\n## bA    -0.61       0 0.15 -0.91 -0.71 -0.61 -0.51 -0.31  2568    1\n## sigma  0.83       0 0.09  0.68  0.76  0.82  0.88  1.02  3049    1\n## \n## Samples were drawn using NUTS(diag_e) at Wed Sep 21 11:06:44 2022.\n## For each parameter, n_eff is a crude measure of effective sample size,\n## and Rhat is the potential scale reduction factor on split chains (at \n## convergence, Rhat=1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# get_variables(model_marriage_divorce_stan)\n\nmodel_marriage_divorce_stan %>% \n  gather_draws(a, bM, bA, sigma) %>% \n  mutate(.variable = factor(.variable, levels = c(\"a\", \"bM\", \"bA\", \"sigma\"))) %>% \n  ggplot(aes(x = .value, y = fct_rev(.variable))) +\n  stat_halfeye() +\n  coord_cartesian(xlim = c(-1, 1))\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-age-marriage-stan-coefs-1.png){width=672}\n:::\n:::\n\n\n:::\n\n#### Simulating causal effects\n\nWe can make counterfactual plots if we model the whole system, just like the [\"full luxury Bayes\" model from video 4](04-video.qmd#full-luxury-bayes).\n\nWe want to know the causal effect of the marriage rate on the divorce rate, or:\n\n$$\nE(\\text{Divorce rate} \\mid \\operatorname{do}(\\text{Marriage rate}))\n$$\n\nHere's model for the whole system:\n\n$$\n\\begin{aligned}\nM_i &\\sim \\mathcal{N}(\\nu_i, \\tau) \\\\\nD_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\nu_i &= \\alpha_M + \\beta_{AM} A_i \\\\\n\\mu_i &= \\alpha + \\beta_M M_i + \\beta_A A_i \\\\\n\\\\\n\\alpha_M &\\sim \\mathcal{N}(0, 0.2) \\\\\n\\alpha &\\sim \\mathcal{N}(0, 0.2) \\\\\n\\beta_{AM} &\\sim \\mathcal{N}(0, 0.5) \\\\\n\\beta_M &\\sim \\mathcal{N}(0, 0.5) \\\\\n\\beta_A &\\sim \\mathcal{N}(0, 0.5) \\\\\n\\tau &\\sim \\operatorname{Exponential}(1) \\\\\n\\sigma &\\sim \\operatorname{Exponential}(1)\n\\end{aligned}\n$$\n\n::: {.panel-tabset}\n##### brms\n\n\n::: {.cell hash='05-video_cache/html/model-dag-full-brms_f7479879ed41a19a189b80293113dc0e'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(0, 0.2), class = Intercept, resp = Divorcez),\n            prior(normal(0, 0.5), class = b, coef = \"Marriage_z\", resp = Divorcez),\n            prior(normal(0, 0.5), class = b, coef = \"MedianAgeMarriage_z\", resp = Divorcez),\n            prior(exponential(1), class = sigma, resp = Divorcez),\n            \n            prior(normal(0, 0.2), class = Intercept, resp = Marriagez),\n            prior(normal(0, 0.5), class = b, coef = \"MedianAgeMarriage_z\", resp = Marriagez),\n            prior(exponential(1), class = sigma, resp = Marriagez))\n\nmodel_dag_full <- brm(\n  bf(Divorce_z ~ Marriage_z + MedianAgeMarriage_z) +\n    bf(Marriage_z ~ MedianAgeMarriage_z) + \n    set_rescor(FALSE),\n  data = WaffleDivorce,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_dag_full)\n##  Family: MV(gaussian, gaussian) \n##   Links: mu = identity; sigma = identity\n##          mu = identity; sigma = identity \n## Formula: Divorce_z ~ Marriage_z + MedianAgeMarriage_z \n##          Marriage_z ~ MedianAgeMarriage_z \n##    Data: WaffleDivorce (Number of observations: 50) \n##   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n##          total post-warmup draws = 4000\n## \n## Population-Level Effects: \n##                               Estimate Est.Error l-95% CI u-95% CI Rhat\n## Divorcez_Intercept                0.00      0.10    -0.20     0.19 1.00\n## Marriagez_Intercept               0.00      0.09    -0.18     0.19 1.00\n## Divorcez_Marriage_z              -0.06      0.16    -0.36     0.25 1.00\n## Divorcez_MedianAgeMarriage_z     -0.61      0.16    -0.91    -0.29 1.00\n## Marriagez_MedianAgeMarriage_z    -0.69      0.10    -0.89    -0.48 1.00\n##                               Bulk_ESS Tail_ESS\n## Divorcez_Intercept                5471     2861\n## Marriagez_Intercept               5718     2909\n## Divorcez_Marriage_z               3565     3160\n## Divorcez_MedianAgeMarriage_z      3484     2710\n## Marriagez_MedianAgeMarriage_z     4943     2673\n## \n## Family Specific Parameters: \n##                 Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sigma_Divorcez      0.83      0.09     0.68     1.02 1.00     4322     2680\n## sigma_Marriagez     0.71      0.07     0.58     0.87 1.00     4992     3220\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_age_divorce <- tibble(MedianAgeMarriage_z = seq(from = -2, to = 2, length.out = 40),\n                          Marriage_z = 0) %>% \n  add_predicted_draws(model_dag_full, resp = \"Divorcez\")\n\nggplot(sim_age_divorce, aes(x = MedianAgeMarriage_z, y = .prediction)) +\n  stat_lineribbon(.width = 0.89, color = clrs[5], fill = clrs[5], alpha = 0.5) +\n  labs(title = \"Total counterfactual effect of age on divorce rate\",\n       subtitle = \"A → D in the DAG\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-sim-age-divorce-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_age_marriage <- tibble(MedianAgeMarriage_z = seq(from = -2, to = 2, length.out = 40)) %>% \n  add_predicted_draws(model_dag_full, resp = \"Marriagez\")\n\nggplot(sim_age_marriage, aes(x = MedianAgeMarriage_z, y = .prediction)) +\n  stat_lineribbon(.width = 0.89, color = clrs[6], fill = clrs[6], alpha = 0.5) +\n  labs(title = \"Counterfactual effect of age on marriage rate\",\n       subtitle = \"A → M in the DAG\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-sim-age-marriage-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsim_age_marriage_divorce <- tibble(Marriage_z = seq(from = -2, to = 2, length.out = 40),\n                                   MedianAgeMarriage_z = 0) %>% \n  add_predicted_draws(model_dag_full, resp = \"Marriagez\")\n\nggplot(sim_age_marriage_divorce, aes(x = Marriage_z, y = .prediction)) +\n  stat_lineribbon(.width = 0.89, color = clrs[3], fill = clrs[3], alpha = 0.5) +\n  labs(title = \"Total counterfactual effect of marriage rate on divorce rate\",\n       subtitle = \"M → D, after adjusting for A in the DAG, or E(D | do(M))\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-sim-age-marriage-divorce-1.png){width=672}\n:::\n:::\n\n\n##### Stan\n\n**marriage_dag_full_stan.stan**\n\n\n::: {.cell output.var='marriage_dag_full_stan' hash='05-video_cache/html/marriage-dag-full-stan_f2a470edca22483a4d4a83ca1305bed3'}\n\n```{.stan .cell-code}\ndata {\n  int<lower=1> n;  // Observations\n  vector[n] Divorce_z;  // Outcome: divorce rate\n  vector[n] Marriage_z;  // \"Treatment\": marriage rate\n  vector[n] MedianAgeMarriage_z;  // Confounder: age\n}\n\nparameters {\n  // Age -> Marriage\n  real aM;\n  real bAM;\n  real<lower=0> tau;\n\n  // Age -> Divorce <- Marriage\n  real a;\n  real bM;\n  real bA;\n  real<lower=0> sigma;\n}\n\nmodel {\n  vector[n] nu;\n  vector[n] mu;\n  \n  // Age -> Marriage\n  aM ~ normal(0, 0.2);\n  bAM ~ normal(0, 0.5);\n  tau ~ exponential(1);\n  \n  nu = aM + bAM*MedianAgeMarriage_z;\n  \n  Marriage_z ~ normal(nu, tau);\n\n  // Age -> Divorce <- Marriage\n  a ~ normal(0, 0.2);\n  bM ~ normal(0, 0.5);\n  bA ~ normal(0, 0.5);\n  sigma ~ exponential(1);\n  \n  mu = a + bM*Marriage_z + bA*MedianAgeMarriage_z;\n\n  Divorce_z ~ normal(mu, sigma);\n}\n\ngenerated quantities {\n  vector[n] Divorce_z_rep;\n  vector[n] Marriage_z_rep;\n  vector[n] divorce_do_marriage;\n  \n  for (i in 1:n) {\n    real nu_hat_n = aM + bAM*MedianAgeMarriage_z[i];\n    real mu_hat_n = a + bM*Marriage_z[i] + bA*MedianAgeMarriage_z[i];\n\n    Marriage_z_rep[i] = normal_rng(nu_hat_n, tau);\n    Divorce_z_rep[i] = normal_rng(mu_hat_n, sigma);\n    divorce_do_marriage[i] = normal_rng(a + bM*Marriage_z_rep[i] + bA*0, sigma);\n  }\n}\n```\n:::\n\n::: {.cell hash='05-video_cache/html/marriage-dag-full-stan-samples_61745f400f927dc094c862c291286103'}\n\n```{.r .cell-code}\nstan_data <- WaffleDivorce %>% \n  select(Divorce_z, Marriage_z, MedianAgeMarriage_z) %>% \n  compose_data()\n\nmodel_marriage_dag_full_stan <- rstan::sampling(\n  object = marriage_dag_full_stan,\n  data = stan_data,\n  iter = 2000, warmup = 1000, seed = BAYES_SEED, chains = 4, cores = 4\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_marriage_dag_full_stan,\n      pars = c(\"aM\", \"bAM\", \"tau\", \"a\", \"bM\", \"bA\", \"sigma\"))\n## Inference for Stan model: ea32b2c9a1ab179009a8845d85ea5d42.\n## 4 chains, each with iter=2000; warmup=1000; thin=1; \n## post-warmup draws per chain=1000, total post-warmup draws=4000.\n## \n##        mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\n## aM     0.00       0 0.09 -0.18 -0.07  0.00  0.06  0.18  5552    1\n## bAM   -0.69       0 0.10 -0.88 -0.75 -0.69 -0.63 -0.50  5583    1\n## tau    0.71       0 0.08  0.58  0.66  0.70  0.76  0.88  5465    1\n## a      0.00       0 0.10 -0.20 -0.07  0.00  0.07  0.20  5541    1\n## bM    -0.06       0 0.16 -0.37 -0.17 -0.06  0.05  0.25  2842    1\n## bA    -0.61       0 0.16 -0.92 -0.71 -0.61 -0.50 -0.29  3314    1\n## sigma  0.83       0 0.09  0.68  0.77  0.82  0.88  1.03  5675    1\n## \n## Samples were drawn using NUTS(diag_e) at Wed Sep 21 11:07:06 2022.\n## For each parameter, n_eff is a crude measure of effective sample size,\n## and Rhat is the potential scale reduction factor on split chains (at \n## convergence, Rhat=1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_age_divorce <- model_marriage_dag_full_stan %>% \n  spread_draws(Divorce_z_rep[i]) %>% \n  mean_hdci() %>% \n  mutate(age = WaffleDivorce$MedianAgeMarriage_z)\n\nggplot(stan_age_divorce, aes(x = age, y = Divorce_z_rep)) +\n  geom_line(color = clrs[5]) +\n  geom_ribbon(aes(ymin = .lower, ymax = .upper), alpha = 0.2, fill = clrs[5]) +\n  coord_cartesian(xlim = c(-2, 2)) +\n  labs(title = \"Total counterfactual effect of age on divorce rate\",\n       subtitle = \"A → D in the DAG\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-stan-age-divorce-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_age_marriage <- model_marriage_dag_full_stan %>% \n  spread_draws(Marriage_z_rep[i]) %>% \n  mean_hdci() %>% \n  mutate(age = WaffleDivorce$MedianAgeMarriage_z)\n\nggplot(stan_age_marriage, aes(x = age, y = Marriage_z_rep)) +\n  geom_line(color = clrs[6]) +\n  geom_ribbon(aes(ymin = .lower, ymax = .upper), alpha = 0.2, fill = clrs[6]) +\n  coord_cartesian(xlim = c(-2, 2)) +\n  labs(title = \"Counterfactual effect of age on marriage rate\",\n       subtitle = \"A → M in the DAG\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-stan-age-marriage-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_age_marriage_divorce <- model_marriage_dag_full_stan %>% \n  spread_draws(divorce_do_marriage[i]) %>% \n  mean_hdci() %>% \n  mutate(age = WaffleDivorce$MedianAgeMarriage_z)\n\nggplot(stan_age_marriage_divorce, aes(x = age, y = divorce_do_marriage)) +\n  geom_line(color = clrs[3]) +\n  geom_ribbon(aes(ymin = .lower, ymax = .upper), alpha = 0.2, fill = clrs[3]) +\n  coord_cartesian(xlim = c(-2, 2)) +\n  labs(title = \"Total counterfactual effect of marriage rate on divorce rate\",\n       subtitle = \"M → D, after adjusting for A in the DAG, or E(D | do(M))\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plot-stan-age-marriage-divorce-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## The pipe (mediators)\n\n$$\nX \\rightarrow Z \\rightarrow Y\n$$\n\n$X$ and $Y$ are associated ($Y \\notind X$) because influence of $X$ is passed to $Y$ through $Z$. After adjusting for $Z$, though, there's no association, or $Y \\ind X \\mid Z$.\n\n### Simulated example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1000\n\npipe_sim <- tibble(X = rbinom(n, 1, prob = 0.5)) %>% \n  # When X is 0, there's a 10% chance of Z being 1\n  # When X is 1, there's a 90% chance of Z being 1\n  # When Z is 0, there's a 10% chance of Y being 1\n  # When Z is 1, there's a 90% chance of Y being 1\n  mutate(Z = rbinom(n, 1, prob = ((1 - X) * 0.1) + (X * 0.9)),\n         Y = rbinom(n, 1, prob = ((1 - Z) * 0.1) + (Z * 0.9)))\n\npipe_sim %>% \n  select(-Z) %>% \n  table()\n##    Y\n## X     0   1\n##   0 403  92\n##   1  73 432\n\npipe_sim %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 1 × 1\n##     cor\n##   <dbl>\n## 1 0.670\n```\n:::\n\n\nBut if we adjust for $Z$, $Y \\ind X \\mid Z$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npipe_sim %>% \n  select(X, Y, Z) %>%\n  table()\n## , , Z = 0\n## \n##    Y\n## X     0   1\n##   0 401  58\n##   1  33   4\n## \n## , , Z = 1\n## \n##    Y\n## X     0   1\n##   0   2  34\n##   1  40 428\n\npipe_sim %>% \n  group_by(Z) %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 2 × 2\n##       Z     cor\n##   <int>   <dbl>\n## 1     0 -0.0145\n## 2     1 -0.0279\n```\n:::\n\n\nThis also works with continuous data. When looking at all values of $Z$, there's a positive slope and relationship; when looking within each group, the relationship is 0 and flat.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 300\n\npipe_sim_cont <- tibble(X = rnorm(n, 0, 1)) %>% \n  mutate(Z = rbinom(n, 1, plogis(X)),\n         Y = rnorm(n, (2 * Z - 1), 1))\n\nggplot(pipe_sim_cont, aes(x = X, y = Y, color = factor(Z))) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  geom_smooth(aes(color = NULL), method = \"lm\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/pipe-sim-continuous-1.png){width=672}\n:::\n:::\n\n\n### Fungus experiment example\n\nWith this DAG, we shouldn't adjust for $F$, since that would block the effect of the fungus, which in this case is super important since the causal mechanism pretty much only flows through $F$. If we adjust for $F$, we'll get the causal effect of the treatment on height *without* the effect of the fungus, which is weird and probably 0.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplant_fungus_dag <- dagify(\n  h1 ~ t + f + h0,\n  f ~ t,\n  exposure = \"t\",\n  outcome = \"h1\",\n  labels = c(t = \"Treatment\", h1 = \"Height, t=1\", f = \"Fungus\", h0 = \"Height, t=0\"),\n  coords = list(x = c(t = 1, h1 = 3, f = 2, h0 = 3),\n                y = c(t = 1, h1 = 1, f = 2, h0 = 2))) %>% \n  tidy_dagitty() %>% \n  node_status()\n\nggplot(plant_fungus_dag, aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point(aes(color = status)) +\n  geom_dag_text(aes(label = label), size = 3.5, color = \"black\") +\n  scale_color_manual(values = clrs[c(1, 4)], guide = \"none\") +\n  theme_dag()\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/plant-dag-1.png){fig-align='center' width=576}\n:::\n:::\n\n\nIn general this is called **post-treatment bias** and it is bad.\n\n\n## The collider (colliders, obvs)\n\n$$\nX \\rightarrow Z \\leftarrow Y\n$$\n\n$X$ and $Y$ are not associated ($Y \\ind X$), but they both influence $Z$. Once you adjust for $Z$, $X$ and $Y$ become associated and $Y \\notind X \\mid Z$.\n\nWhen we learn about $Z$ (or stratify by $Z$, or only look at specific values of $Z$), we necessarily learn something about $X$ and $Y$, since they helped generate $Z$\n\n### Simulated example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 1000\n\ncollider_sim <- tibble(X = rbinom(n, 1, prob = 0.5),\n                       Y = rbinom(n, 1, prob = 0.5)) %>% \n  # If either X and Y are 1, there's a 90% chance that Z will be 1\n  mutate(Z = rbinom(n, 1, prob = ifelse(X + Y > 0, 0.9, 0.2)))\n\n# These are independent\ncollider_sim %>% \n  select(-Z) %>% \n  table()\n##    Y\n## X     0   1\n##   0 248 253\n##   1 240 259\n\n# No correlation\ncollider_sim %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 1 × 1\n##      cor\n##    <dbl>\n## 1 0.0141\n```\n:::\n\n\nWhen we adjust for $Z$, though, $Y \\notind X \\mid Z$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncollider_sim %>% \n  select(X, Y, Z) %>%\n  table()\n## , , Z = 0\n## \n##    Y\n## X     0   1\n##   0 206  25\n##   1  27  17\n## \n## , , Z = 1\n## \n##    Y\n## X     0   1\n##   0  42 228\n##   1 213 242\n\n# They're correlated!\ncollider_sim %>% \n  group_by(Z) %>% \n  summarize(cor = cor(X, Y))\n## # A tibble: 2 × 2\n##       Z    cor\n##   <int>  <dbl>\n## 1     0  0.283\n## 2     1 -0.316\n```\n:::\n\n\nAs with the others, this works with continuous data too. When ignoring values of $Z$, there's no relationship between $X$ and $Y$. But once we adjust for or stratify by $Z$, there's a relationship within each group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 300\n\ncollider_sim_cont <- tibble(X = rnorm(n, 0, 1),\n                            Y = rnorm(n, 0, 1)) %>% \n  mutate(Z = rbinom(n, 1, plogis(2*X + 2*Y - 2)))\n\nggplot(collider_sim_cont, aes(x = X, y = Y, color = factor(Z))) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  geom_smooth(aes(color = NULL), method = \"lm\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/collider-sim-continuous-1.png){width=672}\n:::\n:::\n\n\n### Grant selection example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1914)\n\nn <- 200\n\ngrants <- tibble(newsworthiness = rnorm(n, 0, 1),\n                 trustworthiness = rnorm(n, 0, 1)) %>% \n  mutate(total = newsworthiness + trustworthiness) %>% \n  # Select just the top 10%\n  mutate(q = quantile(total, 1 - 0.1)) %>% \n  mutate(selected = total >= q)\n\n# No relationship\ngrants %>% \n  summarize(cor = cor(newsworthiness, trustworthiness))\n## # A tibble: 1 × 1\n##       cor\n##     <dbl>\n## 1 -0.0672\n\n# Relationship!\ngrants %>% \n  group_by(selected) %>% \n  summarize(cor = cor(newsworthiness, trustworthiness))\n## # A tibble: 2 × 2\n##   selected    cor\n##   <lgl>     <dbl>\n## 1 FALSE    -0.274\n## 2 TRUE     -0.768\n\nggplot(grants, aes(x = newsworthiness, y = trustworthiness, color = selected)) +\n  geom_point() +\n  geom_smooth(data = filter(grants, selected), method = \"lm\") +\n  geom_smooth(aes(color = \"Full sample\"), method = \"lm\")\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/grant-collider-1.png){width=672}\n:::\n:::\n\n\n\n## The descendant\n\nLike a confounder if it comes from a confounder; like a mediator if it comes from a mediator; like a collider if it comes from a collider.\n\n$X$ and $Y$ are causally associated through $Z$, which implies that $Y \\notind X$. $A$ contains information about $Z$, so once we stratify by or adjust for $A$, $X$ and $Y$ become less associated (if $A$ is strong enough), implying $Y \\ind X \\mid A$\n\nThat can be good (if $A$ is confounder-flavored) or bad (if $A$ is mediator- or collider-flavored).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndesc_confounder_dag <- dagify(\n  Y ~ Z,\n  X ~ Z,\n  A ~ Z,\n  coords = list(x = c(X = 1, Y = 3, Z = 2, A = 2),\n                y = c(X = 1, Y = 1, Z = 1, A = 0))) %>% \n  tidy_dagitty()\n\ndesc_mediator_dag <- dagify(\n  Y ~ Z,\n  Z ~ X,\n  A ~ Z,\n  coords = list(x = c(X = 1, Y = 3, Z = 2, A = 2),\n                y = c(X = 1, Y = 1, Z = 1, A = 0))) %>% \n  tidy_dagitty()\n\ndesc_collider_dag <- dagify(\n  Z ~ X + Y,\n  A ~ Z,\n  coords = list(x = c(X = 1, Y = 3, Z = 2, A = 2),\n                y = c(X = 1, Y = 1, Z = 1, A = 0))) %>% \n  tidy_dagitty()\n\nplot_desc_confounder <- ggplot(desc_confounder_dag, \n                               aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point() +\n  geom_dag_text(aes(label = name), size = 3.5, color = \"white\") +\n  ylim(c(-0.25, 1.25)) +\n  labs(subtitle = \"Confounder-flavored descendant\") +\n  theme_dag() +\n  theme(plot.subtitle = element_text(hjust = 0.5, face = \"bold\"))\n\nplot_desc_mediator <- ggplot(desc_mediator_dag, \n                             aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point() +\n  geom_dag_text(aes(label = name), size = 3.5, color = \"white\") +\n  ylim(c(-0.25, 1.25)) +\n  labs(subtitle = \"Mediator-flavored descendant\") +\n  theme_dag() +\n  theme(plot.subtitle = element_text(hjust = 0.5, face = \"bold\"))\n\nplot_desc_collider <- ggplot(desc_collider_dag, \n                             aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point() +\n  geom_dag_text(aes(label = name), size = 3.5, color = \"white\") +\n  ylim(c(-0.25, 1.25)) +\n  labs(subtitle = \"Collider-flavored descendant\") +\n  theme_dag() +\n  theme(plot.subtitle = element_text(hjust = 0.5, face = \"bold\"))\n\nplot_desc_confounder + plot_desc_mediator + plot_desc_collider\n```\n\n::: {.cell-output-display}\n![](05-video_files/figure-html/descendant-dag-1.png){fig-align='center' width=912}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}