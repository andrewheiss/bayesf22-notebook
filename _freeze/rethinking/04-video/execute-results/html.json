{
  "hash": "73cbf9fcf6ea7597459d05f1f6bbbb9c",
  "result": {
    "markdown": "---\ntitle: \"Video #4 code\"\nsubtitle: \"Categories, curves, and splines\"\ndate: \"September 14, 2022\"\neditor_options: \n  chunk_output_type: inline\n---\n\n\n<div class=\"ratio ratio-16x9\">\n<iframe src=\"https://www.youtube.com/embed/QiHKdvAbYII\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n</div>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(brms)\nlibrary(tidybayes)\nlibrary(ggdist)\nlibrary(ggdag)\n\n# Plot stuff\nclrs <- MetBrewer::met.brewer(\"Lakota\", 6)\ntheme_set(theme_bw())\n\n# Seed stuff\nBAYES_SEED <- 1234\nset.seed(1234)\n\n# Data\ndata(Howell1, package = \"rethinking\")\n\nd <- Howell1 %>% \n  filter(age > 18) %>% \n  # Stan doesn't like working with columns with attributes, but I want to keep\n  # the attributes for unscaling later, so there are two scaled height columns\n  mutate(height_scaled = scale(height),\n         height_z = as.numeric(height_scaled)) %>% \n  mutate(sex = factor(male),\n         sex_nice = factor(male, labels = c(\"Female\", \"Male\")))\n\nheight_scale <- attributes(d$height_scaled) %>% \n  set_names(janitor::make_clean_names(names(.)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(Howell1)\n##    height   weight age male\n## 1 151.765 47.82561  63    1\n## 2 139.700 36.48581  63    0\n## 3 136.525 31.86484  65    0\n## 4 156.845 53.04191  41    1\n## 5 145.415 41.27687  51    0\n## 6 163.830 62.99259  35    1\n\nggplot(d, aes(x = height, y = weight, color = sex_nice)) +\n  geom_point() +\n  scale_color_manual(values = clrs[1:2]) +\n  labs(x = \"Height (cm)\", y = \"Weight (kg)\", color = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/explore-data-1.png){width=672}\n:::\n:::\n\n\n## Sex only\n\n$$\n\\begin{aligned}\nW_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\alpha_{S[i]} \\\\\n\\\\\n\\alpha_j &\\sim \\mathcal{N}(60, 10) \\\\\n\\sigma &\\sim \\operatorname{Uniform}(0, 10)\n\\end{aligned}\n$$\n\n::: {.panel-tabset}\n\n### brms\n\nCreate a model with no intercept; use a factor version of `sex` to get the indexes like he does with $\\alpha_{S[i]}$.\n\n\n::: {.cell hash='04-video_cache/html/sex-only_715c76970d85a29162034eae8b89bca8'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(60, 10), class = b),\n            prior(uniform(0, 10), class = sigma, lb = 0, ub = 10))\n\nsex_weight <- brm(\n  bf(weight ~ 0 + sex),\n  data = d,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## Trying to compile a simple C file\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_weight\n##  Family: gaussian \n##   Links: mu = identity; sigma = identity \n## Formula: weight ~ 0 + sex \n##    Data: d (Number of observations: 346) \n##   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n##          total post-warmup draws = 4000\n## \n## Population-Level Effects: \n##      Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sex0    41.87      0.41    41.08    42.65 1.00     3580     3109\n## sex1    48.63      0.43    47.81    49.49 1.00     4090     2920\n## \n## Family Specific Parameters: \n##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sigma     5.52      0.22     5.12     5.98 1.00     4135     2820\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nPosterior mean weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_post_means <- sex_weight %>% \n  gather_draws(b_sex0, b_sex1)\n\nsw_post_means %>% \n  mean_hdci()\n## # A tibble: 2 × 7\n##   .variable .value .lower .upper .width .point .interval\n##   <chr>      <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1 b_sex0      41.9   41.1   42.7   0.95 mean   hdci     \n## 2 b_sex1      48.6   47.7   49.4   0.95 mean   hdci\n\nsw_post_means %>% \n  ggplot(aes(x = .value, fill = .variable)) +\n  stat_halfeye() +\n  scale_fill_manual(values = clrs[1:2]) +\n  labs(x = \"Posterior mean weight (kg)\\n(Coefficient for sex)\", y = \"Density\", fill = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-post-mean-1.png){width=672}\n:::\n:::\n\n\nPosterior mean contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_post_means_wide <- sex_weight %>% \n  spread_draws(b_sex0, b_sex1) %>% \n  mutate(diff = b_sex1 - b_sex0)\n\nsw_post_means_wide %>% \n  select(diff) %>% \n  mean_hdci()\n## # A tibble: 1 × 6\n##    diff .lower .upper .width .point .interval\n##   <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1  6.77   5.63   7.95   0.95 mean   hdci\n\nsw_post_means_wide %>% \n  ggplot(aes(x = diff)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-post-mean-contrast-1.png){width=672}\n:::\n:::\n\n\nPosterior predicted weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_post_pred <- tibble(sex = c(\"0\", \"1\")) %>% \n  add_predicted_draws(sex_weight, ndraws = 1000)\n\nsw_post_pred %>% \n  mean_hdci()\n## # A tibble: 2 × 8\n##   sex    .row .prediction .lower .upper .width .point .interval\n##   <chr> <int>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1 0         1        41.6   30.7   50.9   0.95 mean   hdci     \n## 2 1         2        49.0   38.2   59.3   0.95 mean   hdci\n\nsw_post_pred %>% \n  ungroup() %>% \n  mutate(sex_nice = factor(sex, labels = c(\"Female\", \"Male\"))) %>% \n  ggplot(aes(x = .prediction, fill = sex_nice)) +\n  stat_halfeye(alpha = 0.75) +\n  scale_fill_manual(values = clrs[1:2]) +\n  labs(x = \"Posterior predicted weight (kg)\", y = \"Density\", fill = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-predict-1.png){width=672}\n:::\n:::\n\n\nPosterior predicted contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_post_pred_diff <- tibble(sex = c(\"0\", \"1\")) %>% \n  add_predicted_draws(sex_weight, ndraws = 1000) %>% \n  compare_levels(variable = .prediction, by = sex)\n\nsw_post_pred_diff %>% \n  mean_hdci()\n## # A tibble: 1 × 7\n##   sex   .prediction .lower .upper .width .point .interval\n##   <chr>       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1 1 - 0        7.21  -7.29   21.9   0.95 mean   hdci\n\nsw_post_pred_diff %>% \n  ggplot(aes(x = .prediction)) +\n  stat_halfeye(aes(fill = stat(x > 0))) +\n  geom_vline(xintercept = 0) +\n  scale_fill_manual(values = c(colorspace::lighten(clrs[3], 0.5), clrs[3]),\n                    guide = \"none\") +\n  labs(x = \"Posterior weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-predict-contrast-1.png){width=672}\n:::\n:::\n\n\n\n### Stan\n\n**sw_stan.stan**\n\n\n::: {.cell output.var='sw_stan' hash='04-video_cache/html/sex-only-stan_e7f4216c7de5b835af9eb7bd910de8de'}\n\n```{.stan .cell-code}\ndata {\n  // Stuff from R\n  int<lower=1> n;\n  vector[n] weight;\n  int sex[n];\n}\n\nparameters {\n  // Things to estimate\n  real<lower=0, upper=10> sigma;\n  vector[2] a;\n}\n\ntransformed parameters {\n  vector[n] mu;\n  mu = a[sex];\n}\n\nmodel {\n  // Likelihood\n  weight ~ normal(mu, sigma);\n  \n  // Priors\n  sigma ~ uniform(0, 10);\n  a ~ normal(60, 10);\n}\n\ngenerated quantities {\n  real diff;\n  matrix[n, 2] weight_rep;\n  vector[n] diff_rep;\n  \n  // Calculate the contrasts / difference between group means\n  diff = a[2] - a[1];\n  \n  // Generate a posterior predictive distribution for each sex\n  // To do this we have to create a matrix, with a column per sex\n  for (j in 1:2) {\n    for (i in 1:n) {\n      weight_rep[i, j] = normal_rng(a[j], sigma);\n    }\n  }\n  \n  // Generate a posterior predictive distribution of group contrasts\n  for (i in 1:n) {\n    diff_rep[i] = normal_rng(a[2], sigma) - normal_rng(a[1], sigma);\n  }\n}\n```\n:::\n\n::: {.cell hash='04-video_cache/html/sex-only-stan-samples_8c9889ebc52ad3f1b7693b10655174c2'}\n\n```{.r .cell-code}\nstan_data <- list(n = nrow(d),\n                  weight = d$weight,\n                  sex = d$male + 1)\n\nmodel_sw_stan <- rstan::sampling(\n  object = sw_stan,\n  data = stan_data,\n  iter = 5000, warmup = 1000, seed = BAYES_SEED, chains = 4, cores = 4\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_sw_stan,\n      pars = c(\"sigma\", \"a[1]\", \"a[2]\", \"diff\"))\n## Inference for Stan model: ce4f92ccf1e48f603c1b01a6bf1ee94d.\n## 4 chains, each with iter=5000; warmup=1000; thin=1; \n## post-warmup draws per chain=4000, total post-warmup draws=16000.\n## \n##        mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\n## sigma  5.52       0 0.21  5.12  5.37  5.51  5.66  5.96 14336    1\n## a[1]  41.86       0 0.41 41.05 41.58 41.86 42.14 42.67 14671    1\n## a[2]  48.63       0 0.43 47.79 48.34 48.64 48.92 49.49 15314    1\n## diff   6.77       0 0.60  5.60  6.37  6.77  7.17  7.94 14697    1\n## \n## Samples were drawn using NUTS(diag_e) at Thu Sep 15 01:54:27 2022.\n## For each parameter, n_eff is a crude measure of effective sample size,\n## and Rhat is the potential scale reduction factor on split chains (at \n## convergence, Rhat=1).\n```\n:::\n\n\nPosterior mean weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_stan_post_means <- model_sw_stan %>% \n  gather_draws(a[i])\n## Warning: `gather_()` was deprecated in tidyr 1.2.0.\n## Please use `gather()` instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\nsw_stan_post_means %>% \n  mean_hdci()\n## # A tibble: 2 × 8\n##       i .variable .value .lower .upper .width .point .interval\n##   <int> <chr>      <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1     1 a           41.9   41.1   42.7   0.95 mean   hdci     \n## 2     2 a           48.6   47.7   49.4   0.95 mean   hdci\n\nsw_stan_post_means %>% \n  ungroup() %>% \n  mutate(nice_i = factor(i, labels = c(\"a_female\", \"a_male\"))) %>% \n  ggplot(aes(x = .value, fill = nice_i)) +\n  stat_halfeye() +\n  scale_fill_manual(values = clrs[1:2]) +\n  labs(x = \"Posterior mean weight (kg)\\n(Coefficient for sex)\", y = \"Density\", fill = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-stan-post-mean-1.png){width=672}\n:::\n:::\n\n\nPosterior mean contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_stan_post_diff_means <- model_sw_stan %>% \n  gather_draws(diff)\n\nsw_stan_post_diff_means %>% \n  mean_hdci()\n## # A tibble: 1 × 7\n##   .variable .value .lower .upper .width .point .interval\n##   <chr>      <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1 diff        6.77   5.58   7.92   0.95 mean   hdci\n\nsw_stan_post_diff_means %>% \n  ggplot(aes(x = .value)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-stan-post-mean-contrast-1.png){width=672}\n:::\n:::\n\n\nPosterior predicted weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_weights_stan <- model_sw_stan %>% \n  spread_draws(weight_rep[i, sex])\n\npredicted_weights_stan %>% \n  group_by(sex) %>% \n  mean_hdci()\n## # A tibble: 2 × 10\n##     sex     i i.lower i.upper weight_rep weight_…¹ weigh…² .width .point .inte…³\n##   <int> <dbl>   <int>   <int>      <dbl>     <dbl>   <dbl>  <dbl> <chr>  <chr>  \n## 1     1  174.       1     329       41.9      30.9    52.7   0.95 mean   hdci   \n## 2     2  174.       1     329       48.6      37.8    59.5   0.95 mean   hdci   \n## # … with abbreviated variable names ¹​weight_rep.lower, ²​weight_rep.upper,\n## #   ³​.interval\n\npredicted_weights_stan %>% \n  ungroup() %>% \n  mutate(sex_nice = factor(sex, labels = c(\"Female\", \"Male\"))) %>% \n  ggplot(aes(x = weight_rep, fill = sex_nice)) +\n  stat_halfeye(alpha = 0.75) +\n  scale_fill_manual(values = clrs[1:2]) +\n  labs(x = \"Posterior predicted weight (kg)\", y = \"Density\", fill = NULL) +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-stan-predict-1.png){width=672}\n:::\n:::\n\n\nPosterior predicted contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsw_post_pred_diff_stan <- model_sw_stan %>% \n  gather_draws(diff_rep[i])\n\nsw_post_pred_diff_stan %>%\n  group_by(.variable) %>%\n  mean_hdci() %>% \n  select(-starts_with(\"i\"))\n## # A tibble: 1 × 7\n##   .variable .value .value.lower .value.upper .width .point .interval\n##   <chr>      <dbl>        <dbl>        <dbl>  <dbl> <chr>  <chr>    \n## 1 diff_rep    6.77        -8.63         22.1   0.95 mean   hdci\n\nsw_post_pred_diff_stan %>% \n  ggplot(aes(x = .value)) +\n  stat_halfeye(aes(fill = stat(x > 0))) +\n  geom_vline(xintercept = 0) +\n  scale_fill_manual(values = c(colorspace::lighten(clrs[3], 0.5), clrs[3]),\n                    guide = \"none\") +\n  labs(x = \"Posterior weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-only-stan-predict-contrast-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Sex + height\n\n\n$$\n\\begin{aligned}\nW_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\alpha_{S[i]} + \\beta_{S[i]}(H_i - \\bar{H}) \\\\\n\\\\\n\\alpha_j &\\sim \\mathcal{N}(60, 10) \\\\\n\\beta_j &\\sim \\operatorname{LogNormal}(0, 1) \\\\\n\\sigma &\\sim \\operatorname{Uniform}(0, 10)\n\\end{aligned}\n$$\n\n::: {.panel-tabset}\n\n### brms\n\nThis is the wonkiest syntax ever, but it works! We can hack the `nl` capabilities of **brms** to create indexed parameters.\n\n**Alternatively you can avoid this `nl` syntax!** Use `bf(weight ~ 0 + sex + sex:height_z),` instead. Note the `:` for the interaction term instead of the more standard `*`. If you use `*`, you'll get a more standard interaction term (i.e. the change in the slope when one group is active); if you use `:`, you'll get slopes for each group. [It's a little subtlety in R's formula syntax.](https://stackoverflow.com/questions/40567421/asterisk-vs-colon-in-r-formulas) The `*` is a shortcut for complete crossing of the terms, so `x * z` really turns into `x + z + x:z` behind the scenes. The `:` only does the interaction of the two terms, so that `x:z` is just $x \\times z$.\n\n\n::: {.cell hash='04-video_cache/html/sex-height_272df1d8361c3057a59f22e922493f3f'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(60, 10), class = b, nlpar = a),\n            prior(lognormal(0, 1), class = b, nlpar = b, lb = 0),\n            prior(uniform(0, 10), class = sigma, lb = 0, ub = 10))\n\nmodel_height_sex <- brm(\n  bf(weight ~ 0 + a + b * height_z,\n     a ~ 0 + sex,\n     b ~ 0 + sex,\n     nl = TRUE),\n  data = d,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## Trying to compile a simple C file\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_height_sex\n##  Family: gaussian \n##   Links: mu = identity; sigma = identity \n## Formula: weight ~ 0 + a + b * height_z \n##          a ~ 0 + sex\n##          b ~ 0 + sex\n##    Data: d (Number of observations: 346) \n##   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n##          total post-warmup draws = 4000\n## \n## Population-Level Effects: \n##        Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## a_sex0    45.10      0.46    44.19    45.99 1.00     3021     3038\n## a_sex1    45.19      0.47    44.30    46.11 1.00     2828     2799\n## b_sex0     4.90      0.50     3.88     5.89 1.00     3018     2442\n## b_sex1     4.65      0.45     3.79     5.53 1.00     2964     2861\n## \n## Family Specific Parameters: \n##       Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sigma     4.28      0.17     3.97     4.62 1.00     3600     2789\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsex_height_weight_post_pred <- expand_grid(\n  height_z = seq(min(d$height_z), max(d$height_z), length.out = 50),\n  sex = 0:1\n) %>% \n  add_predicted_draws(model_height_sex) %>%\n  compare_levels(variable = .prediction, by = sex, comparison = list(c(\"0\", \"1\"))) %>% \n  mutate(height_unscaled = (height_z * height_scale$scaled_scale) + height_scale$scaled_center)\n```\n:::\n\n\nOverall distribution of predictive posterior contrasts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(sex_height_weight_post_pred, aes(x = .prediction)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-heights-pred-contrasts-dist-1.png){width=672}\n:::\n:::\n\n\nDistribution of predictive posterior contrasts across range of heights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(sex_height_weight_post_pred, aes(x = height_unscaled, y = .prediction)) +\n  stat_lineribbon(aes(fill_ramp = stat(.width)), .width = ppoints(50),\n                  fill = clrs[3], color = colorspace::darken(clrs[3], 0.5), \n                  show.legend = FALSE) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  scale_fill_ramp_continuous(from = \"transparent\", range = c(1, 0)) +\n  labs(x = \"Height (cm)\", y = \"Posterior weight contrast (kg)\\nWomen − Men\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-heights-pred-contrasts-range-height-1.png){width=672}\n:::\n:::\n\n\n### Stan\n\n:::{.callout-note collapse=\"true\"}\n\n#### Extracting Stan code from *Rethinking* models\n\nThe `ulam()` function is super helpful for translating McElreath's `quap()` syntax into Stan!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_SHW <- rethinking::quap(\n  alist(\n    W ~ dnorm(mu, sigma),\n    mu <- a[S] + b[S] * (H - Hbar),\n    a[S] ~ dnorm(60, 10),\n    b[S] ~ dlnorm(0, 1),\n    sigma ~ dunif(0, 10)\n  ), \n  data = list(\n    W = d$weight,\n    H = d$height,\n    Hbar = mean(d$height),\n    S = d$male + 1\n  )\n)\n\ncat(rethinking::ulam(m_SHW, sample = FALSE)$model)\n## data{\n##     vector[346] W;\n##     real Hbar;\n##     vector[346] H;\n##     int S[346];\n## }\n## parameters{\n##     vector[2] a;\n##     vector<lower=0>[2] b;\n##     real<lower=0,upper=10> sigma;\n## }\n## model{\n##     vector[346] mu;\n##     sigma ~ uniform( 0 , 10 );\n##     b ~ lognormal( 0 , 1 );\n##     a ~ normal( 60 , 10 );\n##     for ( i in 1:346 ) {\n##         mu[i] = a[S[i]] + b[S[i]] * (H[i] - Hbar);\n##     }\n##     W ~ normal( mu , sigma );\n## }\n```\n:::\n\n\n:::\n\n**sex_height.stan**\n\n\n::: {.cell output.var='sex_height_stan' hash='04-video_cache/html/sex-height-stan_0ca133f278d86f3667600a52a47a1129'}\n\n```{.stan .cell-code}\ndata {\n  // Stuff from R\n  int<lower=1> n;\n  vector[n] weight;\n  vector[n] height;\n  int sex[n];\n}\n\ntransformed data {\n  // Center and standardize height\n  vector[n] height_z;\n  height_z = (height - mean(height)) / sd(height);\n}\n\nparameters {\n  // Things to estimate\n  real<lower=0, upper=10> sigma;\n  vector[2] a;\n  vector<lower=0>[2] b;\n}\n\nmodel {\n  vector[n] mu;\n  \n  // Model for mu with intercepts (a) and coefficients (b) for each sex\n  for (i in 1:n) {\n    mu[i] = a[sex[i]] + b[sex[i]] * height_z[i];\n  }\n\n  // Likelihood\n  weight ~ normal(mu, sigma);\n  \n  // Priors\n  sigma ~ uniform(0, 10);\n  a ~ normal(60, 10);\n  b ~ lognormal(0, 1);\n}\n\ngenerated quantities {\n  matrix[n, 2] weight_rep;\n  vector[n] diff_rep;\n  \n  // Generate a posterior predictive distribution for each sex\n  // To do this we have to create a matrix, with a column per sex\n  for (j in 1:2) {\n    for (i in 1:n) {\n      real mu_hat_n = a[sex[i]] + b[sex[i]] * height_z[i];\n      weight_rep[i, j] = normal_rng(mu_hat_n, sigma);\n    }\n  }\n  \n  // Generate a posterior predictive distribution of group contrasts\n  for (i in 1:n) {\n    diff_rep[i] = weight_rep[i, 1] - weight_rep[i, 2];\n  }\n}\n```\n:::\n\n::: {.cell hash='04-video_cache/html/sex-height-stan-samples_822697155a920cc4ad1e2caa4486375d'}\n\n```{.r .cell-code}\nstan_data <- list(n = nrow(d),\n                  weight = d$weight,\n                  height = d$height,\n                  sex = d$male + 1)\n\nmodel_sex_height_stan <- rstan::sampling(\n  object = sex_height_stan,\n  data = stan_data,\n  iter = 5000, warmup = 1000, seed = BAYES_SEED, chains = 4, cores = 4\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_sex_height_stan,\n      pars = c(\"sigma\", \"a[1]\", \"a[2]\", \"b[1]\", \"b[2]\"))\n## Inference for Stan model: f8b7828023f48992dd5011f1f1fa456e.\n## 4 chains, each with iter=5000; warmup=1000; thin=1; \n## post-warmup draws per chain=4000, total post-warmup draws=16000.\n## \n##        mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat\n## sigma  4.28       0 0.17  3.97  4.17  4.28  4.39  4.62 15332    1\n## a[1]  45.10       0 0.45 44.22 44.80 45.10 45.41 45.99 10776    1\n## a[2]  45.20       0 0.46 44.29 44.89 45.20 45.51 46.09 10499    1\n## b[1]   4.91       0 0.49  3.95  4.57  4.91  5.24  5.86 10718    1\n## b[2]   4.65       0 0.43  3.80  4.36  4.65  4.95  5.50 10394    1\n## \n## Samples were drawn using NUTS(diag_e) at Thu Sep 15 01:55:38 2022.\n## For each parameter, n_eff is a crude measure of effective sample size,\n## and Rhat is the potential scale reduction factor on split chains (at \n## convergence, Rhat=1).\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noriginal_hw <- tibble(height = d$height,\n                      weight = d$weight) %>% \n  mutate(i = 1:n())\n\npredicted_diffs_sex_height_stan <- model_sex_height_stan %>% \n  spread_draws(diff_rep[i]) %>% \n  left_join(original_hw, by = \"i\")\n```\n:::\n\n\nOverall distribution of predictive posterior contrasts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(predicted_diffs_sex_height_stan, aes(x = diff_rep)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-heights-stan-pred-contrasts-dist-1.png){width=672}\n:::\n:::\n\n\nDistribution of predictive posterior contrasts across range of heights:\n\n(The y-values are way off from the video here :shrug:)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(predicted_diffs_sex_height_stan, aes(x = height, y = diff_rep)) +\n  stat_lineribbon(aes(fill_ramp = stat(.width)), .width = ppoints(50),\n                  fill = clrs[3], color = colorspace::darken(clrs[3], 0.5), \n                  show.legend = FALSE) +\n  geom_hline(yintercept = 0, linetype = \"dashed\") +\n  scale_fill_ramp_continuous(from = \"transparent\", range = c(1, 0)) +\n  labs(x = \"Height (cm)\", y = \"Posterior weight contrast (kg)\\nWomen − Men\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/sex-heights-stan-pred-contrasts-range-height-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## Full luxury Bayes!\n\nGiven this DAG:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheight_sex_dag <- dagify(\n  x ~ z,\n  y ~ x + z,\n  exposure = \"x\",\n  outcome = \"y\",\n  labels = c(x = \"Height\", y = \"Weight\", z = \"Sex\"),\n  coords = list(x = c(x = 1, y = 3, z = 2),\n                y = c(x = 1, y = 1, z = 2))) %>% \n  tidy_dagitty() %>% \n  node_status()\n\nggplot(height_sex_dag, aes(x = x, y = y, xend = xend, yend = yend)) +\n  geom_dag_edges() +\n  geom_dag_point(aes(color = status)) +\n  geom_dag_text(aes(label = label), size = 3.5) +\n  scale_color_manual(values = clrs[c(1, 4)], guide = \"none\") +\n  theme_dag()\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/full-dag-1.png){fig-align='center' width=480}\n:::\n:::\n\n\n…what's the causal effect of sex on weight? Or:\n\n$$\nE(\\text{Weight} \\mid \\operatorname{do}(\\text{Sex}))\n$$\n\nHere's the official model:\n\n$$\n\\begin{aligned}\nH_i &\\sim \\mathcal{N}(\\nu_i, \\tau) \\\\\nW_i &\\sim \\mathcal{N}(\\mu_i, \\sigma) \\\\\n\\nu_i &= h_{S[i]} \\\\\n\\mu_i &= \\alpha_{S[i]} + \\beta_{S[i]}(H_i - \\bar{H}) \\\\\n\\\\\nh_j &\\sim \\mathcal{N}(160, 10) \\\\\n\\alpha_j &\\sim \\mathcal{N}(60, 10) \\\\\n\\beta_j &\\sim \\operatorname{LogNormal}(0, 1) \\\\\n\\sigma, \\tau &\\sim \\operatorname{Uniform}(0, 10)\n\\end{aligned}\n$$\n\nThe results should look something like this, from the slides:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](04-w-do-s.png){fig-align='center' width=515}\n:::\n:::\n\n\n::: {.panel-tabset}\n\n### brms\n\n\n::: {.cell hash='04-video_cache/html/sex-height-luxury_eb861c15e3ac0358072ed432adb9a889'}\n\n```{.r .cell-code}\npriors <- c(prior(normal(60, 10), resp = weight, class = b, nlpar = a),\n            prior(lognormal(0, 1), resp = weight, class = b, nlpar = b, lb = 0),\n            prior(uniform(0, 10), resp = weight, class = sigma, lb = 0, ub = 10),\n            # prior(normal(160, 10), resp = height, class = b),\n            prior(normal(0, 1), resp = heightz, class = b),\n            prior(uniform(0, 10), resp = heightz, class = sigma, lb = 0, ub = 10))\n\nmodel_luxury <- brm(\n  bf(weight ~ 0 + a + b * height_z,\n     a ~ 0 + sex,\n     b ~ 0 + sex,\n     nl = TRUE) + \n    bf(height_z ~ 0 + sex) + \n    set_rescor(TRUE),\n  data = d,\n  family = gaussian(),\n  prior = priors,\n  chains = 4, cores = 4, seed = BAYES_SEED\n)\n## Compiling Stan program...\n## Trying to compile a simple C file\n## Start sampling\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_luxury\n##  Family: MV(gaussian, gaussian) \n##   Links: mu = identity; sigma = identity\n##          mu = identity; sigma = identity \n## Formula: weight ~ 0 + a + b * height_z \n##          a ~ 0 + sex\n##          b ~ 0 + sex\n##          height_z ~ 0 + sex \n##    Data: d (Number of observations: 346) \n##   Draws: 4 chains, each with iter = 2000; warmup = 1000; thin = 1;\n##          total post-warmup draws = 4000\n## \n## Population-Level Effects: \n##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## weight_a_sex0    42.58      0.64    41.52    44.07 1.01      598      285\n## weight_a_sex1    47.97      0.64    46.49    49.02 1.01      552      313\n## weight_b_sex0     1.09      0.77     0.17     3.02 1.01      565      255\n## weight_b_sex1     0.89      0.70     0.12     2.73 1.01      491      275\n## heightz_sex0     -0.66      0.05    -0.77    -0.55 1.00     2384     1681\n## heightz_sex1      0.74      0.06     0.62     0.85 1.00     2806     2528\n## \n## Family Specific Parameters: \n##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sigma_weight      5.13      0.29     4.49     5.67 1.01      666      291\n## sigma_heightz     0.72      0.03     0.67     0.77 1.00     3262     1965\n## \n## Residual Correlations: \n##                        Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS\n## rescor(weight,heightz)     0.54      0.09     0.32     0.65 1.01      560\n##                        Tail_ESS\n## rescor(weight,heightz)      265\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nPosterior mean contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nluxury_post_mean_diff <- expand_grid(\n  height_z = seq(min(d$height_z), max(d$height_z), length.out = 50),\n  sex = 0:1\n) %>% \n  add_epred_draws(model_luxury) %>%\n  compare_levels(variable = .epred, by = sex, comparison = list(c(\"1\", \"0\")))\n\nluxury_post_mean_diff %>% \n  filter(.category == \"weight\") %>% \n  ggplot(aes(x = .epred)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/luxury-mean-contrast-1.png){width=672}\n:::\n:::\n\n\nPosterior predicted contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nluxury_post_pred_diff <- expand_grid(\n  height_z = seq(min(d$height_z), max(d$height_z), length.out = 50),\n  sex = 0:1\n) %>% \n  add_predicted_draws(model_luxury) %>%\n  compare_levels(variable = .prediction, by = sex, comparison = list(c(\"1\", \"0\")))\n\nluxury_post_pred_diff %>% \n  filter(.category == \"weight\") %>% \n  ggplot(aes(x = .prediction)) +\n  stat_halfeye(aes(fill = stat(x > 0))) +\n  geom_vline(xintercept = 0) +\n  scale_fill_manual(values = c(colorspace::lighten(clrs[3], 0.5), clrs[3]),\n                    guide = \"none\") +\n  labs(x = \"Posterior weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/luxury-predict-contrast-1.png){width=672}\n:::\n:::\n\n\n### Stan\n\n:::{.callout-note collapse=\"true\"}\n\n#### Extracting Stan code from *Rethinking* models\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm_SHW_full <- rethinking::quap(\n  alist(\n    # Weight\n    W ~ dnorm(mu, sigma),\n    mu <- a[S] + b[S] * (H - Hbar),\n    a[S] ~ dnorm(60, 10),\n    b[S] ~ dlnorm(0, 1),\n    sigma ~ dunif(0, 10),\n    \n    # Height\n    H ~ dnorm(nu, tau),\n    nu <- h[S],\n    h[S] ~ dnorm(160, 10),\n    tau ~ dunif(0, 10)\n  ), data = list(\n    W = d$weight,\n    H = d$height,\n    Hbar = mean(d$height),\n    S = d$male + 1\n  )\n)\n\ncat(rethinking::ulam(m_SHW_full, sample = FALSE)$model)\n```\n:::\n\n\n:::\n\n**luxury_stan.stan**\n\n\n::: {.cell output.var='luxury_stan' hash='04-video_cache/html/luxury-stan_b91c5257b62552b154b50c83e44bb175'}\n\n```{.stan .cell-code}\ndata {\n  // Stuff from R\n  int<lower=1> n;\n  vector[n] weight;\n  real Hbar;\n  vector[n] height;\n  int sex[n];\n}\n\nparameters {\n  // Things to estimate\n  vector[2] a;\n  vector<lower=0>[2] b;\n  real<lower=0,upper=10> sigma;\n  vector[2] h;\n  real<lower=0,upper=10> tau;\n}\n\nmodel {\n  vector[n] mu;\n  vector[n] nu;\n  \n  // Height model\n  tau ~ uniform(0, 10);\n  h ~ normal(160, 10);\n  \n  for (i in 1:n) {\n    nu[i] = h[sex[i]];\n  }\n  \n  // Weight model\n  height ~ normal(nu , tau);\n  sigma ~ uniform(0, 10);\n  b ~ lognormal(0, 1);\n  a ~ normal(60, 10);\n  \n  for (i in 1:n) {\n    mu[i] = a[sex[i]] + b[sex[i]] * (height[i] - Hbar);\n  }\n  \n  weight ~ normal(mu, sigma);\n}\n\ngenerated quantities {\n  matrix[n, 2] weight_rep;\n  matrix[n, 2] height_rep;\n  vector[n] w_do_s;\n  vector[2] mu_sex;\n  real mu_diff;\n  \n  for (i in 1:2) {\n    mu_sex[i] = a[sex[i]] + b[sex[i]] * (h[sex[i]] - Hbar);\n  }\n  \n  mu_diff = mu_sex[1] - mu_sex[2];\n  \n  // Generate a posterior predictive distribution for each sex\n  // To do this we have to create a matrix, with a column per sex\n  for (j in 1:2) {\n    for (i in 1:n) {\n      height_rep[i, j] = normal_rng(h[sex[j]], tau);\n      weight_rep[i, j] = normal_rng(a[sex[j]] + b[sex[j]] * (height_rep[i, j] - Hbar), sigma);\n    }\n  }\n  \n  // Generate a posterior predictive distribution of group contrasts\n  for (i in 1:n) {\n    w_do_s[i] = weight_rep[i, 1] - weight_rep[i, 2];\n  }\n}\n```\n:::\n\n::: {.cell hash='04-video_cache/html/luxury-stan-samples_6350883e3633ee795fefb17c585e3ac1'}\n\n```{.r .cell-code}\nstan_data <- list(n = nrow(d),\n                  weight = d$weight,\n                  height = d$height,\n                  Hbar = mean(d$height),\n                  sex = d$male + 1)\n\nmodel_luxury_stan <- rstan::sampling(\n  object = luxury_stan,\n  data = stan_data,\n  iter = 5000, warmup = 1000, seed = BAYES_SEED, chains = 4, cores = 4\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(model_luxury_stan,\n      pars = c(\"a[1]\", \"a[2]\", \"b[1]\", \"b[2]\", \"sigma\", \"h[1]\", \"h[2]\", \"tau\", \n               \"mu_sex[1]\", \"mu_sex[2]\", \"mu_diff\"))\n## Inference for Stan model: 2ac72225665508fb4100c7f800818c3a.\n## 4 chains, each with iter=5000; warmup=1000; thin=1; \n## post-warmup draws per chain=4000, total post-warmup draws=16000.\n## \n##             mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat\n## a[1]       45.18       0 0.46  44.28  44.87  45.17  45.48  46.08 12392    1\n## a[2]       45.14       0 0.46  44.25  44.83  45.14  45.45  46.03 12553    1\n## b[1]        0.65       0 0.06   0.52   0.60   0.65   0.69   0.77 12075    1\n## b[2]        0.61       0 0.06   0.50   0.57   0.61   0.65   0.72 13048    1\n## sigma       4.28       0 0.16   3.97   4.17   4.28   4.39   4.62 21039    1\n## h[1]      149.50       0 0.41 148.70 149.21 149.50 149.78 150.30 22463    1\n## h[2]      160.37       0 0.44 159.52 160.08 160.37 160.67 161.22 22320    1\n## tau         5.57       0 0.21   5.18   5.43   5.56   5.71   6.01 19301    1\n## mu_sex[1]  48.63       0 0.42  47.79  48.35  48.63  48.92  49.46 21139    1\n## mu_sex[2]  41.85       0 0.42  41.04  41.57  41.85  42.13  42.67 21824    1\n## mu_diff     6.78       0 0.59   5.62   6.37   6.78   7.18   7.94 20965    1\n## \n## Samples were drawn using NUTS(diag_e) at Thu Sep 15 01:56:43 2022.\n## For each parameter, n_eff is a crude measure of effective sample size,\n## and Rhat is the potential scale reduction factor on split chains (at \n## convergence, Rhat=1).\n```\n:::\n\n\nPosterior mean contrast in weights:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nluxury_post_mean_diff_stan <- model_luxury_stan %>% \n  spread_draws(mu_diff)\n\nluxury_post_mean_diff_stan %>% \n  mean_hdci()\n## # A tibble: 1 × 6\n##   mu_diff .lower .upper .width .point .interval\n##     <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n## 1    6.78   5.64   7.95   0.95 mean   hdci\n\nggplot(luxury_post_mean_diff_stan, aes(x = mu_diff)) +\n  stat_halfeye(fill = clrs[3]) +\n  labs(x = \"Posterior mean weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/luxury-stan-mean-contrast-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nluxury_post_pred_diff_stan <- model_luxury_stan %>% \n  spread_draws(w_do_s[i])\n\nluxury_post_pred_diff_stan %>% \n  mean_hdci()\n## # A tibble: 346 × 7\n##        i w_do_s .lower .upper .width .point .interval\n##    <int>  <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n##  1     1   6.79  -8.96   21.5   0.95 mean   hdci     \n##  2     2   6.86  -8.69   22.2   0.95 mean   hdci     \n##  3     3   6.79  -8.46   22.6   0.95 mean   hdci     \n##  4     4   6.86  -9.38   21.3   0.95 mean   hdci     \n##  5     5   6.71  -8.26   22.7   0.95 mean   hdci     \n##  6     6   6.85  -8.15   22.8   0.95 mean   hdci     \n##  7     7   6.78  -8.74   22.4   0.95 mean   hdci     \n##  8     8   6.85  -8.36   22.6   0.95 mean   hdci     \n##  9     9   6.82  -8.79   21.9   0.95 mean   hdci     \n## 10    10   6.80  -8.53   21.8   0.95 mean   hdci     \n## # … with 336 more rows\n\nggplot(luxury_post_pred_diff_stan, aes(x = w_do_s)) +\n  stat_halfeye(aes(fill = stat(x > 0))) +\n  geom_vline(xintercept = 0) +\n  scale_fill_manual(values = c(colorspace::lighten(clrs[3], 0.5), clrs[3]),\n                    guide = \"none\") +\n  labs(x = \"Posterior weight contrast (kg)\\nWomen − Men\", y = \"Density\")\n```\n\n::: {.cell-output-display}\n![](04-video_files/figure-html/luxury-stan-predict-contrast-1.png){width=672}\n:::\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}